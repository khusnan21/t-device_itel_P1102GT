    #!/system/bin/sh

  clear
 dir="/data/local/binary"
 export PATH=/data/local/binary:$PATH
 #export LD_LIBRARY_PATH="/data/local/binary/lib"
 #PS3=" =>: "
 
 dir_ch="/data/local/Unpacker"
 for dir_real in "System" "Qfil" "Payload" "UpdateApp" "Super" "Contexts" "Preloader"; do
 if busybox test ! -d "$dir_ch""$dir_real"; then
 busybox mkdir -p "$dir_ch""$dir_real" 2> /dev/null && busybox chmod 755 "$dir_ch""$dir_real"
 fi
 done
 
 busybox find /data/local/UnpackerSystem/gen_keys -maxdepth 1 -empty -exec busybox rm -rf {} \; 2> /dev/null
  busybox find /data/local/UnpackerSystem/extract_keys -maxdepth 1 -empty -exec busybox rm -rf {} \; 2> /dev/null
 
 
config="config/$pack_d"
 
 free_place()
{
 unset get_size
 unset get_size_print

 echo
 echo
 echo ".....Enter the desired amount of free space for the image being built in megabytes:"
 echo
 read a && set -- "$a"  
if [ $(echo $?) -eq 0 ]; then
if busybox test "$(busybox expr "$a" \* "1" 2> /dev/null)"; then
 get_size="$(busybox expr "$a" \* 1024 \* 1024 / 4096 \* 4096)"
 get_size_print="$a"
 set -- "$get_size"
else
 get_size="0"
 get_size_print="0"
 set -- "$get_size"
fi
else
 echo
 echo ".....Error!"
 echo
fi
 clear
 echo
 echo ".....The desired amount of free space for the image being built is set ~ "$get_size_print" mb"
 echo
 return
}

 nn1()
{

 echo
 echo "     Selecting the folder to save the image to    "
 echo "     -----------------------------    "
 echo
 echo ".....When entering 0, the save folder is: /data/local/UnpackerSuper/output"
 echo ".....When entering 1, the save folder is: /data/local/UnpackerSuper"
 echo ".....Enter 0, 1, or your path to the image save folder..."
 #echo "  For example: 0" 
 #echo "  For example: /sdcard/test"
 #echo "  input example: /storage/F960-18E7"
 echo
 read h && if [ "$h" = "0" ]; then
 outdir=/data/local/UnpackerSystem
 set -- $outdir
 
            clear
            echo
 echo "     Output image save folder is set:"
 echo "     $outdir"
 elif [ "$h" = "1" ]; then
 outdir=/data/local/UnpackerSuper
 set -- $outdir
 
            clear
            echo
 echo "     Output image save folder is set:"
 echo "     $outdir"
 elif [ -d "$h" ]; then
 outdir=$h
 set -- $outdir
 
 clear
            echo
 echo "     Output image save folder is set:"
 echo "     $outdir"
 else
 clear
 echo
 echo ".....The save folder does not exist!"
 nn
 return
 fi
 return
}

inf_space_menu()
{
free_space="$(busybox df -h "$outdir" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
echo "    В папке freely: "$free_space""
return
}

qsn()
{
if [ -f /data/local/binary/path_list.txt ]; then
 v=$(for a in $(busybox cat /data/local/binary/path_list.txt); do

 echo "$a"
     done | busybox sort -f)

 set -- $v

if [ ! -z "$v" ]; then
 clear
 echo
 echo ".....Select the output folder from the list in the file /data/local/binary/path_list.txt: "
 echo
select menu in $v "/data/local/UnpackerSystem"; do
case $REPLY in
                 [1-9]*) i="$#"
                        #j="$#"
                      let i=i+1
                      #let j=j+2
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 if [ -d "$file" ]; then
 clear        
outdir="$file"
 set -- $outdir
 
 else
 clear
 outdir="/data/local/UnpackerSystem"
        set -- $outdir
 echo
 echo ".....Folder $file does not exist!"
 fi
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        #main_menu
        outdir="/data/local/UnpackerSystem"
        set -- $outdir
        return
        break
        else
        clear
        #echo
            #echo "      Enter the numbers corresponding to the menu."
         outdir="/data/local/UnpackerSystem"
        set -- $outdir
         return
         break
         fi
         break;;
   *) clear
        #echo
            #echo "      Enter the numbers corresponding to the menu."
         outdir="/data/local/UnpackerSystem"
         set -- $outdir
         return
         break ;;
  esac
 done
 else
 clear
 echo
 echo ....."There are no paths written in the path_list.txt file."
 echo
 outdir="/data/local/UnpackerSystem"
 set -- $outdir
return
fi
else
clear
echo
 echo ....."No file /data/local/binary/path_list.txt!"
 echo
 outdir="/data/local/UnpackerSystem"
 set -- $outdir
return
fi
return
}


nn()
{

 echo
 echo "     Selecting the folder to save the image to    "
 echo "     -----------------------------    "
 echo
 #echo ".....When entering 0, the save folder is: /data/local/UnpackerSystem"
 echo ".....When you press \"Enter\", the save folder /data/local/UnpackerSystem..."
 echo ".....When entering 0, select a folder from the list in the file /data/local/binary/path_list.txt..."
 echo
 echo ".....Click \"Enter\", enter 0 or your path to the image save folder..."
 echo
 read h && if [ "$h" = "0" ]; then

 qsn #function for selecting a folder from a list.
 #set -- $outdir
 #mkdir "$outdir" 2> /dev/null
 
            #clear
            echo
 echo "    Output image save folder is set:"
 echo "    $outdir"
  inf_space_menu
 elif [ -d "$h" -o -d /"$h" -a ! -z "$h" ]; then
 outdir=/"$(echo "$h" | busybox sed 's!^/!!')"
 set -- $outdir
 make_ext4fs -l 10485760 "$outdir"/testuka >/dev/null
  if busybox test -s "$outdir"/testuka; then
 
 clear
            echo
 echo "    The output image save folder is set:"
 set -- $outdir
 echo "    $outdir"
  inf_space_menu
 busybox rm -f "$outdir"/testuka 2> /dev/null
 else
 clear
 echo
 echo "    \"$outdir\" not available for saving image!"
 echo
 echo "    The output image save folder is set:"
 outdir=/data/local/UnpackerSystem
 set -- $outdir
 mkdir "$outdir" 2> /dev/null
 echo "    $outdir"
  inf_space_menu
 busybox rm -f "$outdir"/testuka 2> /dev/null
 fi
 else
 clear
 echo
 echo "....Warning! Save folder does not exist!"
 echo
 echo "    The output image save folder is set:"
 outdir=/data/local/UnpackerSystem
 set -- $outdir
 mkdir "$outdir" 2> /dev/null
 echo "    $outdir"
  inf_space_menu
 return
 fi
 return
}

 nnnnn()
{

 echo
 echo "     Selecting the folder to save the image to    "
 echo "     -----------------------------    "
 echo
 echo ".....When entering 0, the save folder is: /data/local/UnpackerSystem"
 echo ".....Enter 0 or your path to the image save folder..."
 echo
 read h && if [ "$h" = "0" ]; then
 outdir=/data/local/UnpackerSystem
 set -- $outdir
 
            clear
            echo
 echo "     The output image save folder is set:"
 echo "     $outdir"
 elif [ -d "$h" -o -d /"$h" ]; then
 outdir=/"$(echo "$h" | busybox sed 's!^/!!')"
 set -- $outdir
 make_ext4fs -l 10485760 "$outdir"/testuka >/dev/null
  #if [ $(echo $?) -eq 0 ]; then
  if busybox test -s "$outdir"/testuka; then
 
 clear
            echo
 echo "     The output image save folder is set:"
 set -- $outdir
 echo "     $outdir"
 busybox rm -f "$outdir"/testuka 2> /dev/null
 else
 clear
 echo
 echo "    \"$outdir\" not available for saving image!"
 echo
 echo "    The output image save folder is set:"
 outdir=/data/local/UnpackerSystem
 set -- $outdir
 echo "    $outdir"
 busybox rm -f "$outdir"/testuka 2> /dev/null
 fi
 else
 outdir="$h"
 set -- $outdir

 clear
 echo
 echo ".....Error! The save folder does not exist!"
 nnnnn
 return
 fi
 return
}



 check_status () {

 make_ext4fs -s -J -T -1 -l "$i" -a /"$pack_d" tmp.img "$pack_d" &> /dev/null
 if [ $(echo $?) -eq 0 ]; then
 gg=1
 return
 else
 gg=0
 return
 fi
 return
}

 check_size_img()
{
 #cd /data/local/UnpackerSystem
 echo
 echo ".....Determining the size for assembly..."
 echo

#i="$(avbtool add_hashtree_footer --partition_size "$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)" --do_not_generate_fec --calc_max_image_size)"

if [ "$erof" == "2" ]; then

i=$(busybox cat "$config"/"$pack_d"_size.txt)
else
 i="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 fi

 #i=$(busybox cat "$config"/"$pack_d"_size.txt)


 while check_status &> /dev/null; do
if [ "$gg" -eq 1 ]; then
if busybox test -s "$config"/"$pack_d"_avb.img; then
 c="$(avbtool add_hashtree_footer --partition_size "$i" --do_not_generate_fec --calc_max_image_size)"
 v="$(avbtool add_hashtree_footer --partition_size "$c" --do_not_generate_fec --calc_max_image_size)"
 
until busybox test "$i" -lt "$v";
 do
 v="$(busybox expr "$v" \+ "$get_add")"
 c="$(busybox expr "$c" \+ "$get_add")"
 done
 size_new="$(busybox expr "$c" / 4096 \* 4096 \+ "$get_size")"
 else
 size_new="$(busybox expr "$i" / 4096 \* 4096 \+ "$get_size")"
 fi
 busybox rm -f tmp.img
 break
 else
 i="$(busybox expr "$i" \+ "$get_add")"
 fi
 done
 return
}



ext_check()
{
 file_ext="$1"

 if [ ! -z "$(busybox hexdump -C -n 20000 "$file_ext" | busybox grep -Eo '3a ff 26 ed|30 50 4c 41|4d 4f 54 4f|e2 e1 f5 e0|28 b5 2f fd|55 42 49 23|10 20 f5 f2' 2> /dev/null)" -o ! -z "$(busybox hexdump -C -n 2000 "$file_ext" | busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" -o ! -z "$(busybox hexdump -C -n 2000 "$file_ext" | busybox grep -o "[.]cms" 2> /dev/null)" ]; then
if  [ -z "$(echo "$file_ext" | busybox grep -o "\-cow.img")" ]; then
 return 0
else
return 1
fi
return 0
 else
 return 1
 fi
 return
}


 ext_checkkk()
{
 file_ext="$1"

 if [ ! -z "$(busybox hexdump -C -n 2000 "$file_ext" | busybox grep '3a ff 26 ed')" -o ! -z "$(busybox hexdump -C -n 2000 "$file_ext" | busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" -o ! -z "$(busybox hexdump -C -n 20000 "$file_ext" | busybox grep -o "30 50 4c 41")" -o ! -z "$(busybox hexdump -C -n 20000 "$file_ext" | busybox grep -o "4d 4f 54 4f" 2> /dev/null)" -o ! -z "$(busybox hexdump -C -n 2000 "$file_ext" | busybox grep -o "[.]cms" 2> /dev/null)" ]; then
 return 0
 else
 return 1
 fi
 return
}


 ext_check_super()
{
 file_ext="$1"
if [ ! -z "$(busybox hexdump -C -n 2000 "$file_ext" | busybox grep '3a ff 26 ed')" -o ! -z "$(busybox hexdump -C -n 2000 "$file_ext" | busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" ]; then
 return 0
 else
 return 1
 fi
 return
}

 check_mount()
{
 [ -z "$(busybox mount | busybox grep "/data/local" | busybox grep -vi "AIK")" ] && return 0 || return 1
}
 

my_size_add()
{
 clear
 real_size_orig="$(cat "$config"/"$pack_d"_size.txt)"
 real_size_orig_mb=$(busybox expr "$real_size_orig" / 1024 / 1024)
 echo
 echo ".....Original image size ~ "$real_size_orig_mb" mb"
 echo ".....Enter the size in mb you want to add to the image:"
 echo
 read a && set -- "$a"  
 if [ $(echo $?) -eq 0 ]; then
 #real_size_orig="$(cat "$config"/"$pack_d"_size.txt)"
 #real_size_orig_mb=$(busybox expr "$real_size_orig" / 1024 / 1024)
 size_add=$(busybox expr "$a" \* 1024 \* 1024 / 4096 \* 4096)
r_size=$(busybox expr "$real_size_orig" + "$size_add")
real_size=$(busybox expr "$r_size" / 1024 / 1024)
 set -- "$r_size"

 fff_add
 return
 echo
 else
 echo
 echo ".....Error!"
 echo
 my_size_add
 return
 fi
 return
}

 fff_add()
{
 clear
  if [ "$r_size" != 0 ]; then
 echo
 echo "...Original image size ~ "$real_size_orig_mb" mb"
 echo "...Assemble an image with size ~ ${real_size} mb?"
 echo
 #else
 #echo
 #echo "...The entered size is not a multiple of \"4096\", build an image with the size: $r_size bytes?"
 #echo
 fi
 select img in "Yes" "No, enter another size" "Exit to main menu"; do
 case $REPLY in 
         1 ) set -- "$r_size"
             if [ ! -s "$config"/"$pack_d"*_avb.img ]; then
    #set -- "$b"
    #busybox cp -f "$config"/"$pack_d"*_avb.img "$config"/"$pack_d"_myavb.img
      #cat $file_sh > "$config"/"$pack_d"_gsize.sh
            #else
        busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
              fi
              . $file_size
               main_menu
               break ;;
         2 ) clear
               my_size_add
               return
               break ;;
         3 ) clear
               main_menu
               return
               break ;;
         * ) clear
             echo
             echo "      Enter the numbers corresponding to this menu."
              fff_add
              return
              break ;;
    esac
done
return
}

 my_size()
{
 clear
 echo
 echo ".....Enter size in bytes:"
 echo
 read a && set -- "$a"  
 if [ $(echo $?) -eq 0 ]; then
 r_size=$(busybox expr "$a" / 4096 \* 4096)
 set -- "$r_size"

 fff
 return
 echo
 else
 echo
 echo ".....Error!"
 echo
 my_size
 return
 fi
 return
}

 fff()
{
 clear
  if [ "$a" = "$r_size" ]; then
 echo
 echo "...Build image with size: $r_size bytes?"
 echo
 else
 echo
 echo "...The entered size is not a multiple of \"4096\", build an image with the size: $r_size bytes?"
 echo
 fi
 select img in "Yes" "No, enter another size" "Exit to main menu"; do
 case $REPLY in 
         1 ) set -- "$r_size"
             if [ ! -s "$config"/"$pack_d"*_avb.img ]; then
    #set -- "$b"
    #busybox cp -f "$config"/"$pack_d"*_avb.img "$config"/"$pack_d"_myavb.img
      #cat $file_sh > "$config"/"$pack_d"_gsize.sh
            #else
        busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
              fi
              . $file_size
               main_menu
               break ;;
         2 ) clear
               my_size
               return
               break ;;
         3 ) clear
               main_menu
               return
               break ;;
         * ) clear
             echo
             echo "      Enter the numbers corresponding to this menu."
              fff
              return
              break ;;
    esac
done
return
}


   pack_dat()
{
 cd /data/local/UnpackerSystem
 dir=/data/local/binary
 d=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $d

 if [ ! -z "$d" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $d "Exit to the main menu"; do
case $REPLY in
                [1-9]*) i="$#"

 let i=i+1

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
 pack_d="$file"
 config="config/$pack_d"
 
 size=100
 #. ${dir}/pack_img_dat
 . $file_size
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$i" ]; then
 clear
 main_menu
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to the menu."
 pack_dat
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to the menu."
 pack_dat
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for build."
 echo
 main_menu
 return
fi
return
}

  pack_dat_my()
{
 cd /data/local/UnpackerSystem
 dir=/data/local/binary
 d=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $d

 if [ ! -z "$d" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $d "Exit to the main menu"; do
case $REPLY in
                [1-9]*) i="$#"

 let i=i+1

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
 pack_d="$file"
 config="config/$pack_d"
 
 size=111
 set -- $size
 if [ -f ./"$config"/"$pack_d"*_avb.img ]; then
         file_sh=./"$config"/"$pack_d"*_pack_avb_sparse.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack_sparse.sh
          fi
 #file_size=${dir}/pack_img_dat
 if [ "$size_add" == "1" ]; then
     my_size_add
 else
 my_size
 fi
 return

 main_menu
 return
 break
 elif [ "$REPLY" -eq "$i" ]; then
 clear
 main_menu
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to the menu."
 pack_dat_my
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to the menu."
 pack_dat_my
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for build."
 echo
 main_menu
 return
fi
return
}


  pack_dat_new()
{
 
  free_place
  
 cd /data/local/UnpackerSystem
 dir=/data/local/binary
 d=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $d

 if [ ! -z "$d" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $d "Collect all images" "Exit to main menu" "Exit work"; do
case $REPLY in
 [1-9]*) i="$#"
        j="$#"
        e="$#"

 let i=i+1
 let j=j+2
 let e=e+3
 

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
 pack_d="$file"
 config="config/$pack_d"
 
 size_orig="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
if busybox test "$size_orig" -le "10485760"; then
 get_add="8192"
  check_size_img
 #size_new="$(busybox expr "$size_orig" \* 109 / 105 / 4096 \* 4096)"
else
 get_add="1048576"
 check_size_img
 #size_new="$(busybox expr "$size_orig" \* 12 / 11 / 4096 \* 4096)"
  fi
                    size=111
                    set -- $size
                   r_size="$size_new"
                   set -- $r_size
                    #file_size=${dir}/pack_img_dat
         if busybox test -s ./"$config"/"$pack_d"*_avb.img; then
         file_sh=./"$config"/"$pack_d"*_pack_avb_sparse.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack_sparse.sh
         busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
          fi
              . $file_size
          main_menu
     return
 break
 elif [ "$REPLY" -eq "$i" ]; then

 clear
 for br_pack in "$@"; do
 check_dat="222"
 pack_d="$br_pack"
 config="config/$pack_d"
 
 size_orig="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
if busybox test "$size_orig" -le "10485760"; then
 get_add="8192"
  check_size_img
 #size_new="$(busybox expr "$size_orig" \* 109 / 105 / 4096 \* 4096)"
else
 get_add="1048576"
 check_size_img
 #size_new="$(busybox expr "$size_orig" \* 12 / 11 / 4096 \* 4096)"
  fi
                    size=111
                    set -- $size
                   r_size="$size_new"
                   set -- $r_size
                    #file_size=${dir}/pack_img_dat
         if busybox test -s ./"$config"/"$pack_d"*_avb.img; then
         file_sh=./"$config"/"$pack_d"*_pack_avb_sparse.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack_sparse.sh
         busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
          fi
              . $file_size
              sleep 3
  done
 main_menu
 return
 break
elif [ "$REPLY" -eq "$j" ]; then
 clear
 main_menu
 return
 break
elif [ "$REPLY" -eq "$e" ]; then
 clear
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to the menu."
 pack_dat_new
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to the menu."
 pack_dat_new
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for assembly."
 echo
 main_menu
 return
fi
return
}

 main_menu(){
 echo -en "\E[32;1m"
 MENU=(       "Menu: Extraction file_contexts"
             "Menu: AIK-mobile Repackaging boot(recovery).img"
             "Menu: Unpacking .img"
             "Menu: Mounting raw images *.img"
             "Menu: Unpacking .dat"
             "Menu: Unpacking .br"
             "Menu: Assembly .img"
             "Menu: Assembly and conversion to .dat"
             "Menu: Assembly and conversion to .br"
             "Menu: Conversion sparse > raw; raw > sparse"
             "Menu: Other tools"
             "Menu: Cleaning up working folders"
             "Menu: Removal \"Unpacker Kitchen for Android\""
             "Completion of work"
)
echo
echo "                 Main Menu:"
echo "          version 5.38 64-bit only"
echo "           Translate By : @Diagoo1"
echo "              --------------"
echo
echo "   Enter the number corresponding to the desired action:"
echo
echo -en "\E[37;1m"

select menu in "${MENU[@]}"; do
    case $REPLY in
         1) clear
            my1(){
            echo
            echo ".....Item 1 is not relevant (disabled)"
            main_menu
            return
            echo
            echo "      Menu: Extraction file_contexts"
             echo
             echo "     Put it down boot.img в папку: /data/local/UnpackerContexts"
             echo
select img in "Extract file_contexts" "Converting file_contexts(txt) -> file_contexts(bin)(version:8.38)" "Installing configuration" "Exit to main Menu" "Exit"; do
case $REPLY in 
         1 ) clear
             bootext
             main_menu
             break ;;
         2 ) clear
             cd /data/local/UnpackerContexts
             if [ -f ./file_contexts ]; then
             $dir/sefcontext_compile -o ./file_contexts_new.bin ./file_contexts
             if [ $(echo $?) -eq 0 ] ; then
echo
echo ".....Successfully created file_contexts_new.bin!"
echo
else
echo
echo ".....error: Error during conversion!"
echo
fi
else
echo 
echo ".....There is no file in the folder: file_contexts!"
echo
fi
             cd
             main_menu
             break ;;
         3 ) clear
             /data/local/binary/install_sef.sh
             main_menu
             break ;;
         4 ) clear
             main_menu
             break ;;
         5 ) clear
             break ;;
          *) echo "Enter the number corresponding to the Menu items: Extraction file_contexts." ;;
    esac
done
}
my1
break ;;
         2) clear
             my_aik(){
             if [ -d /data/local/AIK-mobile ]; then
            cd /data/local/AIK-mobile
             echo
             echo "         Menu: AIK-mobile"
             echo
             echo "    Put boot.img in a folder: /data/local/AIK-mobile"
             echo
select img in "Unpack boot(recovery)" "Pack boot(recovery)" "Remove AVB/dm-verity" "Patch boot.img(32bit, SAR) for magisk" "Cleaning the working folder: /data/local/AIK-mobile" "Completely removing AIK-mobile from the phone" "Exit to the main Menu" "Shutdown"; do
case $REPLY in 
         1 ) clear
             aik_mob="1"
             my_sel_boot(){
 aik_avb()
{
 avb_file="$1"
 avb_dir=/data/local/AIK-mobile/split_img
 if [ -d "$avb_dir" ]; then

 avb_full="$(avbtool info_image --image "$avb_file" 2> "$avb_dir"/avb.log)"
 if [ ! -z "$(echo "$avb_full" | busybox grep -o "Image size:")" ]; then
 
 #echo "$avb_full" | busybox awk '/Partition Name:/ { print $3 }' > "$avb_dir"/part_name.txt
 echo "$avb_full" | busybox awk '/Footer version:/,/Chain Partition descriptor:/ {if ($1=="Partition") print $3 }' > "$avb_dir"/part_name.txt
 echo "$avb_full" > "$avb_dir"/avb.img
 echo "$avb_full" | busybox awk '/Image size:/ { print $3 }' | busybox head -1 > "$avb_dir"/avb_size.txt
 
 if [ ! -s "$avb_dir"/part_name.txt ]; then
 if [ ! -z "$(ls "$avb_dir" | busybox grep -Eoi 'init_boot' | busybox head -1)" ]; then
 echo "init_boot" > "$avb_dir"/part_name.txt
 elif [ ! -z "$(ls "$avb_dir" | busybox grep -Eoi "vendor_'boot" | busybox head -1)" ]; then
 echo "vendor_boot" > "$avb_dir"/part_name.txt
 elif [ ! -z "$(ls "$avb_dir" | busybox grep -Eoi "twrp|recovery" | busybox head -1)" ]; then
 echo "recovery" > "$avb_dir"/part_name.txt
 else
 echo "boot" > "$avb_dir"/part_name.txt
 fi
 fi
 
 echo
 echo ".....AVB structure discovered!"
 fi
 fi
return
}
cd /data/local/AIK-mobile
b=$(busybox find . -maxdepth 1 -name '*.img' -o -name '*.sin' -o -name '*.elf' -o -name '*.bin' -o -name '*.win' -o -name '*.lz4' -o -name '*.PARTITION' -type f | busybox sort -f)

set -- $b

if [ ! -z "$b" ]; then
echo
echo ".....Select file to unzip:"
echo
select menu in $b "Exit to Menu: AIK-mobile"; do
case $REPLY in
    [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         outfile=$(echo "$file" | busybox awk -F".lz4" '{ print $1 }')
         if [ ! -z "$(echo "$file" | busybox grep -o '.lz4$')" ]; then
         lz4 -df "$file"
         ./unpackimg.sh "$outfile" && aik_avb "$outfile" && . /data/local/binary/extract_key "$outfile"
        busybox hexdump -C -n 2000 "$outfile" | busybox grep -o "56 4e 44 52 42 4f 4f 54" > ./split_img/name_vndr.txt
        echo "$outfile" | busybox grep -o "init_boot" > ./split_img/name_init.txt
         


         elif [ ! -z "$(echo "$file" | busybox grep ".sin$")" ]; then
        name_sin="$(echo "$file" | busybox sed 's!\.sin$!!')"
        sony_dump "$PWD" "$file" | tee "$name_sin"_sin.log

        if [ $(echo $?) -eq 0 ]; then
     [ -f "$name_sin"_sin.log ] && u="$(busybox cat "$name_sin"_sin.log | busybox awk '/Extracting file/ { print $3 }' | busybox tail -1)" 
num=${u##*/}
       busybox mv -f "$num" "$name_sin"_sin.img && ./unpackimg.sh "$name_sin"_sin.img && aik_avb "$name_sin"_sin.img && . /data/local/binary/extract_key "$name_sin"_sin.img
          busybox hexdump -C -n 2000 "$name_sin"_sin.img | busybox grep -o "56 4e 44 52 42 4f 4f 54" > ./split_img/name_vndr.txt
          echo "$name_sin"_sin.img | busybox grep -o "init_boot" > ./split_img/name_init.txt
         fi

         else
         
         ./unpackimg.sh "$file" && aik_avb "$file" && . /data/local/binary/extract_key "$file"
         busybox hexdump -C -n 2000 "$file" | busybox grep -o "56 4e 44 52 42 4f 4f 54" > ./split_img/name_vndr.txt
         echo "$file" | busybox grep -o "init_boot" > ./split_img/name_init.txt
         fi
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        my_aik
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_sel_boot
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_sel_boot
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no files in the folder to unpack.."
 echo
 my_aik
 return
 fi
return
}
 my_sel_boot
 break
             my_aik
             break ;;
         2 ) clear
 aik_pack()
 {
 unset sign_file
 unset sign_print
 unset hash_alg
 pack_file="$(echo "$1" | busybox sed 's!./!!')"
 #pack_file="$1"
 avb_dir=/data/local/AIK-mobile/split_img
 if busybox test -s "$avb_dir"/avb.img; then
 size_orig="$(busybox cat "$avb_dir"/avb_size.txt)"
 check_part_name="$(busybox cat "$avb_dir"/part_name.txt)"
 [ ! -z "$check_part_name" ] && part_name="$check_part_name" || part_name="\" \""
 prop_avb="$(busybox cat "$avb_dir"/avb.img | busybox awk '/    Prop:/ { print "--prop"" "$2":"$4 }' | tr '\n' ' ')"
 
 check_alg="$(busybox cat "$avb_dir"/avb.img | busybox awk '/^Algorithm:/ { print $2 }')"
 check_hash_alg="$(busybox cat "$avb_dir"/avb.img | busybox awk '/Hash Algorithm:/ { print $3 }')"
  [ ! -z "$check_hash_alg" ] && hash_alg="--hash_algorithm $check_hash_alg"

#if [ "$check_alg" != "NONE" -a ! -z "$check_alg" ]; then
# if [ "$check_alg" == "SHA256_RSA2048" ]; then
# sign_file="--key /data/local/binary/testkey_rsa2048.pem"
# sign_print="--algorithm $check_alg"
# elif [ "$check_alg" == "SHA256_RSA4096" ]; then
 #sign_file="--key /data/local/binary/testkey_rsa4096.pem"
# sign_print="--algorithm $check_alg"
 
 #elif [ "$check_alg" == "SHA256_RSA8192" ]; then
 #sign_file="--key /data/local/binary/testkey_rsa8192.pem"
# sign_print="--algorithm $check_alg"
# fi
 #fi


if [ "$check_alg" != "NONE" -a ! -z "$check_alg" ]; then
 case "$check_alg" in
   "SHA256_RSA2048" ) sign_file="--key /data/local/binary/testkey_rsa2048.pem"
 sign_print="--algorithm $check_alg" ;;
   "SHA256_RSA4096" ) sign_file="--key /data/local/binary/testkey_rsa4096.pem"
 sign_print="--algorithm $check_alg" ;;
 
   "SHA256_RSA8192" ) sign_file="--key /data/local/binary/testkey_rsa8192.pem"
 sign_print="--algorithm $check_alg" ;;
 esac
fi


 echo "avbtool add_hash_footer --image "$pack_file" --partition_size "$size_orig" "$prop_avb"--partition_name "$part_name" "$hash_alg" "$sign_print" "$sign_file"" > "$avb_dir"/avb.sh
 #chmod 755 "$avb_dir"/avb.sh && "$avb_dir"/avb.sh && busybox rm -f "$avb_dir"/avb.sh
 chmod 755 "$avb_dir"/avb.sh && "$avb_dir"/avb.sh
 if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Minimal AVB structure created!"
 
 r="$(busybox realpath "$pack_file")"
 nd=${r%/*}

 . /data/local/binary/remove_key "$pack_file" "$avb_dir"/*_pubkey.pem
 else
 echo
 echo ".....Error creating AVB structure!"
 fi
 else
 size_img="$(busybox cat "$avb_dir"/*-origsize 2> /dev/null)"
 if [ ! -z "$size_img" ]; then

 size_mb="$(busybox expr "$size_img" / 1024 / 1024)"
 fi
 if [ ! -z "$(echo "$size_mb" | busybox grep -Eow "6|16|24|32|35|40|54|64|96|100|128|192")" ]; then
 size_orig="$(busybox expr "$size_mb" \* 1024 \* 1024)"
 if busybox test "$size_img" -eq "$size_orig"; then
 busybox truncate -s "$size_orig" "$pack_file" 2> /dev/null
 fi
 fi
 fi
 return
}
             ./repackimg.sh
              if [ -d ./split_img ]; then
              cd /data/local/AIK-mobile/split_img
              
          #if [ -s ./part_name.txt ]; then
              #n_part="$(busybox cat ./part_name.txt)"
              #cd ..
                           #busybox mv -f ./image-new.img ./"${n_part}"-output.img && aik_pack ./"${n_part}"-output.img
           #else           
check_name_obraz="$(ls | busybox grep -Eoi 'boot|twrp|recovery|magisk|cwm' | busybox head -1)"
case "$check_name_obraz" in
              "boot" )  if [ ! -z "$(busybox cat name_vndr.txt | busybox grep -o "56 4e 44 52 42 4f 4f 54")" ]; then
                           cd ..
                           busybox mv -f ./image-new.img ./vendor_boot-output.img && aik_pack ./vendor_boot-output.img
                         elif [ ! -z "$(busybox cat name_init.txt | busybox grep -o "init_boot")" ]; then
                        cd ..
                           busybox mv -f ./image-new.img ./init_boot-output.img && aik_pack ./init_boot-output.img    
                          else
                          cd ..
                           busybox mv -f ./image-new.img ./boot-output.img && aik_pack ./boot-output.img
                           fi;;
 twrp|recovery|cwm )  cd ..
                        busybox mv -f ./image-new.img ./recovery-output.img && aik_pack ./recovery-output.img ;;
            "magisk" )  cd ..
                                 busybox mv -f ./image-new.img ./magisk-output.img && aik_pack ./magisk-output.img ;;
                    * )  cd ..
                                 busybox mv -f ./image-new.img ./unknown-output.img && aik_pack ./unknown-output.img ;;
esac
#fi
fi

             my_aik
             break ;;

         3 ) clear
             rr()
{
file="$1"
busybox rm -rf path
mkdir path && cd path
bootpatch unpack ../$file 2> ../path_dtb.txt
if [ "$?" -eq "0" ]; then
echo >> ../path_dtb.txt

#echo
#echo "...Looking for values ​​for the patch..."
clear
for file_path in $(busybox find -maxdepth 1 -name "*dtb"); do
[ -f $file_path ] && echo
echo "...Finding values ​​for a patch in a file: $(echo $file_path | busybox sed "s!./!!")..." && /data/local/binary/bootpatch dtb $file_path patch &>> ../path_dtb.txt
done
if [ ! -z "$(busybox cat ../path_dtb.txt | busybox grep ".*,avb")" ]; then
echo >> ../path_dtb.txt
bootpatch repack ../$file 2>> ../path_dtb.txt && busybox cp new-boot.img ../boot_noavb.img && busybox rm -rf ../path
#echo >> ../path_dtb.txt
echo
echo "...Successfully completed, file received: \"boot_noavb.img\"!"
echo
main_menu
return
else
echo
echo "...No values ​​for patch!"
echo
busybox rm -rf ../path
main_menu
return
fi
else
echo
echo "...Error while unpacking!"
busybox rm -rf ../path
 main_menu
 return
 fi
}


             clear_dm(){

cd /data/local/AIK-mobile
b=$(busybox find . -maxdepth 1 -name '*.img' -o -name '*.sin' -o -name '*.elf' -o -name '*.bin' -o -name '*.lz4' -type f)

set -- $b

if [ ! -z "$b" ]; then
echo
echo ".....Select file:"
echo
select menu in $b "Exit to Menu: AIK-mobile"; do
case $REPLY in
    [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         outfile=$(echo "$file" | busybox awk -F".lz4" '{ print $1 }')
         if [ ! -z "$(echo "$file" | busybox grep -o '.lz4$')" ]; then
         lz4 -df "$file"
         rr "$outfile"
         return
         else
         rr "$file"
         return
         fi
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        my_aik
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         clear_dm
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         clear_dm
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no files for patching in the folder."
 echo
 my_aik
 return
 fi
return
}
 clear_dm
    break

              my_aik
              break ;;
         4 ) clear
            ker_path(){

cd /data/local/AIK-mobile
b=$(busybox find . -maxdepth 1 -name '*.img' -type f)

set -- $b

if [ ! -z "$b" ]; then
echo
echo ".....Select file:"
echo
select menu in $b "Exit to Menu: AIK-mobile"; do
case $REPLY in
                     [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
       ker_name="$(echo "$file" | busybox sed 's!^./!!' | busybox awk -F".img" '{ print $1 }')"
       file="$ker_name".img
       file1="$ker_name"_path.img
       busybox cp -f "$file" "$file1"
       echo
       python31 /data/local/binary/bin_system/main.py "$file1" 2> ker.txt
         if [ $(echo $?) -eq 0 ] ; then
        echo
        echo ".....Successfully patched $file -> $file1"
        echo
        else
        echo
        busybox cat ker.txt | busybox grep "Exception:"
        busybox rm -f "$file1"
        echo
        fi
        busybox rm -f ker.txt
         my_aik
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        my_aik
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         ker_path
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         ker_path
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no files for patching in the folder."
 echo
 my_aik
 return
 fi
return
}
 ker_path
  break
            my_aik
              break ;;
         5 ) clear
             ./cleanup.sh
              my_aik
              break ;;
         6 ) clear
             del_aik()
{
echo
echo -en "\E[31;47;1m"
echo "     Delete AIK-mobile from phone?     "
echo
echo -en "\E[37;0m"
echo -en "\E[37;1m"
select img in "Yes" "No" "Exit to the main Menu"; do
case $REPLY in 
         1 ) clear
               /data/local/AIK-mobile/cleanup.sh
 /data/local/AIK-mobile/bin/aik --uninstall
 busybox mount -o rw,remount / 2> /dev/null
 busybox mount -o rw,remount /system 2> /dev/null
              busybox find $(echo $PATH | busybox sed 's!:! !g') -name 'aik' -type f | xargs busybox rm -f 2> /dev/null
 busybox rm -rf /data/local/AIK-mobile /data/adb/modules/aik-mobile 2> /dev/null

if [ $(echo $?) -eq 0 ]; then
echo
echo "     AIK-mobile successfully removed!"
echo
fi
               main_menu
               break ;;
         2 ) clear
               main_menu
               break ;;
         3 ) clear
              main_menu
               break ;;
         *) clear
            echo
            echo "      Enter the numbers corresponding to this Menu."
              del_aik
              break ;;
    esac
done
return
}
del_aik
break ;;
         7 ) clear
              main_menu
              break;;
         8 ) clear
             break ;;
         *) echo
            echo "     Enter the number corresponding to the Menu items: AIK-mobile" ;;
    esac
done
 else
 echo
#echo -en "\E[31;47;1m"
echo ".....AIK-mobile not installed!"
 echo
#echo -en "\E[37;0m"
#echo -en "\E[37;1m"

 main_menu
 return
 fi
 return
}
my_aik
break ;;
         3) clear

             my_system()
{
             cd /data/local/UnpackerSystem
             
 #clear
 dir_dat=/data/local/binary
 #b=/data/local/UnpackerSuper
 #nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
 v=$(for a in $(busybox find . -maxdepth 1 -name '*.img' -type f | busybox sed 's!./!!'); do
    
  ext_check "$a"

     if [ $(echo $?) -eq 0 ]; then
       echo "$a"
     fi
     done | busybox sort -f)

 set -- $v

 if [ ! -z "$v" ]; then
 echo
 echo ".....We are in the folder: /$nd"
 echo ".....Select file to unzip:"
 echo
 select menu in $v "Exit to the main Menu"; do
 case $REPLY in
    [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         file=/"$nd"/"$file"
         . ${dir_dat}/unpack_img
         main_menu
         return
         break
         elif [ "$REPLY" -eq "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_system
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_system
         return
         break;;
  esac
 done
 else
 echo
 echo ".....There are no images \".img\" to unpack in the folder: /$nd."
 echo
 main_menu
return
 fi
return
}

 my_sin()
{
if [ ! -z "$(echo "$file" | busybox grep ".sin$")" ]; then
        
        name_sin="$(busybox basename ${file%.*})"
         
        sony_dump "$PWD" "$file"
        if [ $(echo $?) -eq 0 ]; then
      num="$(busybox find -maxdepth 1 | busybox grep -Ev ".sin$|.crt$|.img$|.log$" | busybox grep "$name_sin")"
       busybox mv -f "$num" "$name_sin"_sin.img && file=/"$nd"/"$name_sin"_sin.img

       ext_check "$file"
       
    if [ "$(echo $?)" -eq "0" ]; then
      
      . ${dir_dat}/unpack_img
      else
      echo
         echo ".....Conversion completed successfully!"
         echo ".....Received file $file"
         echo
      echo "...The file has zero size or unsupported format, further Unpacking is not possible!"
      echo
     fi
         fi
          else
        ext_check "$file"
         if [ "$(echo $?)" -eq "0" ]; then
        . ${dir_dat}/unpack_img
        else
     echo
     echo "...The file has zero size or unsupported format, further Unpacking is not possible!"
      echo
         fi
         fi
  return
}
qqq()
       {
       free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 #echo "...В /${nd} freely: $free_space"
 echo -e "\033[33;1m...В /${nd} freely: $free_space \033[0m"
 if [ "$free_space" != "$free_data" ]; then
 #echo "...В /data freely: $free_data"
 echo -e "\033[33;1m...В /data freely: $free_data \033[0m"
 fi
return
}

             my_super()
{

   dir_dat=/data/local/binary
            
   if [ "$nd" == "data/local/UnpackerSystem" ]; then
   cd /"$nd" && echo "$nd" > "$dir_dat"/last.txt
   elif [ "$nd" == "data/local/UnpackerSuper" ]; then
   cd /"$nd" && echo "$nd" > "$dir_dat"/last.txt
  elif [ "$nd" == "data/local/UnpackerPayload" ]; then
   cd /"$nd" && echo "$nd" > "$dir_dat"/last.txt
   elif [ "$nd" == "data/local/UnpackerSystem/uka_backup" -a -d /"$nd" ]; then
   cd /"$nd" && echo "$nd" > "$dir_dat"/last.txt
   elif [ "$nd" == "data/local/UnpackerQfil" -a -d /"$nd" ]; then
   cd /"$nd" && echo "$nd" > "$dir_dat"/last.txt
   elif [ "$nd" == "$(busybox cat "$dir_dat"/last.txt 2> /dev/null)" -a -d /"$nd" ]; then
   cd /"$nd" && echo "$nd" > "$dir_dat"/last.txt
   fi
             
 #dir_dat=/data/local/binary
 #b=/data/local/UnpackerSuper
 #nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')

 echo
 echo ".....Search for images..."
 v=$(busybox find . -maxdepth 1 -name '*.img' -o -name '*.zst' -o -name '*.PARTITION' -type f -o -name '*.sin' -o -name '*.win' -o -name "*.ubi" -o -name "*.ubifs" -type f | busybox sed 's!./!!' | while read a; do
    
  ext_check $a

     if [ $(echo $?) -eq 0 ]; then
       echo "$a"
     fi
     done | busybox sort -f)

set -- $v

 if [ ! -z "$v" -a "$PWD" == "/$nd" -a "$PWD" != "/" ]; then
 clear
 free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "...We are in the folder: /$nd"
 echo "...В /${nd} freely: $free_space"
 if [ "$free_space" != "$free_data" ]; then
 echo "...В /data freely: $free_data"
 fi
 

 echo
 echo ".....Select file to unzip:"
 echo
 select menu in $v "Unpack all images" "Exit to main Menu" "Shutdown"; do
 case $REPLY in
                   [1-9]*) i="$#"
                      j="$#"
                      e="$#"
                      let i=i+1
                      let j=j+2
                      let e=e+3
                      #let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         file=/"$nd"/"$file"
       my_sin
         main_menu
         return
         break
         elif [ "$REPLY" -eq "$i" ]; then
         clear
        for bin in "$@"; do
       if [ ! -z "$(busybox hexdump -C -n 20000 /"$nd"/"$bin" | busybox grep -o "30 50 4c 41")" -a "$nd" == "data/local/UnpackerSuper" ]; then
      echo
      echo -e "\033[33;1m.....Missed Unpacking "$bin" \033[0m"
      unset file
      continue
        else
         file=/"$nd"/"$bin"
         fi
       my_sin
       qqq
       done
        main_menu
        return
        break
        elif [ "$REPLY" -eq "$j" ]; then
         clear
        main_menu
        return
        break
        elif [ "$REPLY" -eq "$e" ]; then
         clear
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_super
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_super
         return
         break;;
  esac
 done
 else
 echo
 echo ".....There are no supported \".img\" images in the folder: /$nd to unpack."
 echo
 main_menu
return
 fi
return
}
             my_d()
{
 
             cd
             echo 
             echo "...Go to the folder where the files are located: \".img\", for example: cd /sdcard"
read b && $b
 if [ $(echo $?) -eq 0 ]; then
 clear
 echo
 echo ".....Search for images..."
 
 dir_dat=/data/local/binary
 nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!') && echo "$nd" > /data/local/binary/last.txt
 v=$(for a in $(busybox find . -maxdepth 1 -name '*.img' -o -name '*.zst' -o -name '*.sin' -o -name '*.win' -o -name "*.ubi" -o -name "*.ubifs" -o -name '*.PARTITION' -type f -o -iname "*super" -type l | busybox sed 's!./!!'); do

  ext_check $a

   if [ $(echo $?) -eq 0 ]; then
      echo "$a"
     fi
     done | busybox sort -f)

set -- $v

 if [ ! -z "$v" ]; then
 clear
 free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "...We are in the folder: /$nd"
 echo "...В /${nd} freely: $free_space"
 if [ "$free_space" != "$free_data" ]; then
 echo "...В /data freely: $free_data"
 fi
 echo
 echo ".....Select file to unzip:"
 echo
select menu in $v "Unpack all images" "Exit to main Menu" "Shutdown"; do
case $REPLY in
                  [1-9]*) i="$#"
                      j="$#"
                      e="$#"
                      let i=i+1
                      let j=j+2
                      let e=e+3
                      #let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
    #if [ "$(echo "$file" | busybox grep "*..PARTITION$")" ]; then
    #file=/"$nd"/"$(busybox mv "$file" "$file".img)"
    #else
         file=/"$nd"/"$file"
         #fi

        my_sin 
         main_menu
         return
         break
         elif [ "$REPLY" -eq "$i" ]; then
         clear
        for bin in "$@"; do
        if [ ! -z "$(busybox hexdump -C -n 20000 /"$nd"/"$bin" | busybox grep -o "30 50 4c 41")" -a "$nd" == "data/local/UnpackerSuper" ]; then
      echo
      echo -e "\033[33;1m.....Missed Unpacking "$bin" \033[0m"
      unset file
      continue
        else
         file=/"$nd"/"$bin"
         fi
       my_sin
       qqq
       done 
        main_menu
        return
        break
        elif [ "$REPLY" -eq "$j" ]; then
         clear
        main_menu
        return
        break
        elif [ "$REPLY" -eq "$e" ]; then
         clear
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_d
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_d
         return
         break;;
  esac
 done
 else
 echo
 echo ".....There are no supported \".img\" images in the folder: /$nd to unpack."
 echo
 main_menu
return
 fi
echo
else
echo
echo ".....error: Error moving to directory!"
echo
echo "Please enter the directory correctly!"
echo
my_d
return
fi
return
}
            my_new(){

            echo
            echo "      Menu: Unpacking .img"
            echo
select menu in  "Unpacking .img from folder: /data/local/UnpackerSystem" "Unpacking .img from folder: /data/local/UnpackerSuper" "Unpacking .img from folder: /data/local/UnpackerPayload" "Unpacking .img from folder: /data/local/UnpackerSystem/uka_backup" "Unpacking .img from folder: /data/local/UnpackerQfil" "Unpacking .img from last used folder" "Enter path to folder with .img image" "Exit to main Menu" "Shutdown"; do
 case $REPLY in
             1 ) clear
         nd=data/local/UnpackerSystem
         #my_system
         my_super
         return
         main_menu
         return
         break ;;
       2 ) clear
         nd=data/local/UnpackerSuper
         my_super
         return
         main_menu
         return
         break ;;
       3 ) clear
         nd=data/local/UnpackerPayload
         my_super
         return
         main_menu
         return
         break ;;
       4 ) clear
         nd=data/local/UnpackerSystem/uka_backup
         my_super
         return
         main_menu
         return
         break ;;
       5 ) clear
         nd=data/local/UnpackerQfil
         my_super
         return
         main_menu
         return
         break ;;
       6 ) clear
        last_dir="$(busybox cat /data/local/binary/last.txt 2> /dev/null | busybox sed 's!^/!!')"
         if [ ! -z "$last_dir" -a -d /"$last_dir" ]; then
         nd="$last_dir"
         my_super
         return
         main_menu
         return
         else
         echo
         echo ".....The last folder has not been defined yet!"
         echo
         main_menu
         return
         fi
         
         #my_super
         #return
         #main_menu
         #return
         break ;;
       7 ) clear
        
         my_d
         return
         main_menu
         return
         break ;;
       8 ) clear
               main_menu
                     break ;;
       9 ) clear
                 return
                    break ;;
       * ) clear
            echo
            echo "      Enter the numbers corresponding to Menu." 
              my_new
              break ;;
  esac
 done
return
}
 my_new
 break;;
         4) clear
            my_mount()
{
 
 #check_mount
 #if [ $(echo $?) -eq 0 ] ; then
 #busybox rm -f /data/local/binary/papka.txt
 #fi
 #home_dir="/data/local/UnpackerSystem"
 cd $home_dir
 my_dir="/data/local/binary"
 > $my_dir/mm
 > $my_dir/mm1
 > $my_dir/spars
 #> $my_dir/fs_ext
 echo
 echo ".....Search for images..."

 obraz=$(a=$(busybox find "$home_dir" -maxdepth 1 -name '*.img' -type f | busybox sed "s!$home_dir!!")
 set -- $a

 for v in $a; do



 if [ "$(echo $v | busybox awk '{ print $3 }' | busybox grep "$v")" != "$(for i in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50; do
      loop=/dev/block/loop$i;

      busybox losetup $loop 2> /dev/null | busybox grep "$v" | busybox awk '{ print $3 }'
done)" ]; then

 zik=$(echo $v)
 zik1=$(echo $v | busybox sed "s!$home_dir!!" | busybox sed 's!.img!!')
 if [ "$home_dir" != /data/local/UnpackerSystem/ ]; then
 echo "$zik смонтирован в папку: /data/local/$zik1" >> $my_dir/mm1
 else
 echo "$zik смонтирован в папку: /data/local/$zik1" >> $my_dir/mm
 fi
 else
 if [ -z "$(busybox hexdump -C -n 20000 "$v" | busybox grep '3a ff 26 ed')" ]; then
 if [ ! -z "$(busybox hexdump -C -n 2000 "$v"| busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" ]; then
 echo $v
 else
 echo $v > /dev/null
 fi
 else
 echo $v >> $my_dir/spars
 fi
 fi
 done)
 set -- $obraz

 if busybox test -s "$my_dir/mm" -o -s "$my_dir/mm1"; then
 clear
 echo
 echo
 echo "   Already mounted images in the folder: \"/$print_dir\""
 busybox cat $my_dir/mm
 busybox cat $my_dir/mm1

 else
 clear
 echo
 echo "   There are no mounted images in the folder: \"/$print_dir\""
 echo
 fi

 if busybox test -s "$my_dir/spars"; then
 echo
 echo "   imageы sparse в папке /$print_dir:"
 busybox cat $my_dir/spars
 fi

 if [ ! -z "$obraz" ]; then
 echo
 echo "   Available raw images for mounting. Select file:"
 echo " --------------------------------------------------------"
 echo
 select menu in $obraz "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         if [ -z "$(busybox hexdump -C -n 20000 "$file" | busybox grep '3a ff 26 ed')" ]; then
         if [ ! -z "$(busybox hexdump -C -n 2000 "$file" | busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" ]; then
          a=$(echo $file | busybox sed -e 's!./!!; s!.img!!')

         . /data/local/binary/my_mounting

          busybox echo -ne "/data/local/$a|" >> /data/local/binary/papka.txt

          main_menu
          return
          else
          echo
          echo
          echo "   $file is not an image ext4."
          main_menu
          return
          break
          fi
          else
          echo
          echo
          echo "   $file is a sparse image. To mount, convert to raw.img."
          main_menu
          return
          fi
         main_menu
         return
         break
         elif [ "$REPLY" -eq "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_mount
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_mount
         return
         break;;
  esac
 done
 
 else
 echo
 echo "   There are no *.img files available for mounting in the folder: \"/$print_dir\"."
 echo
 main_menu
 return
 fi
 return
}


        my_d()
{
             cd
             echo 
             echo "...Go to the folder where the files are located: \".img\", for example: cd /sdcard"
read b && $b
 if [ $(echo $?) -eq 0 ]; then
 clear

 home_dir="$PWD/"
 print_dir="$(echo "$PWD" | busybox sed 's!^/!!')"

 my_mount
 return
 else
 echo
 echo ".....error: Error moving to directory!"
 echo
 echo "Please enter the directory correctly!"
 echo
 my_d
 return
 fi
 return
}
            my10(){
            echo
            echo "      Menu: Mounting raw images *.img"
            echo "     --------------------------------------"
            echo
select img in "Mount image from folder: /data/local/UnpackerSystem" "Enter path to folder with .img image to mount" "Unmount image" "Exit to the main Menu" "Shutdown"; do
case $REPLY in 
         1 ) clear
             home_dir="/data/local/UnpackerSystem/"
             print_dir="data/local/UnpackerSystem"
             my_mount
             break ;;
         2 ) clear
             my_d
             break ;;
         3 ) clear
             sel_umount(){
if [ -z "$file" ]; then
         clear
         main_menu
         return
      else
          clear
         . /data/local/binary/my_unmounting
         check_mount
 if [ $(echo $?) -eq 0 ] ; then
 busybox rm -f /data/local/binary/papka.txt
 fi
          main_menu
          return
          fi
return
}

my_umount(){
 if busybox test -s /data/local/binary/papka.txt; then
 p="$(busybox cat /data/local/binary/papka.txt 2> /dev/null | busybox sed -e 's!|$!!; s!\+!\\+!')"

 b=$(busybox mount | busybox cut -d" " -f3 | busybox grep -E "$p") 2> /dev/null
 else
 unset b
fi

 set -- $b

if [ ! -z "$b" ]; then
echo
echo "     Select a folder to unmount:"
echo
select menu in $b "Exit to the main Menu"; do
case $REPLY in
      1) file="$1"
         clear
         sel_umount
         break;;
      2) file="$2"
         clear
         sel_umount
         break;;
      3) file="$3"
         clear
         sel_umount
         break;;
      4) file="$4"
         clear
         sel_umount
         break;;
      5) file="$5"
         clear
         sel_umount
         break;;
      6) file="$6"
         clear
         sel_umount
         break;;
      *) clear
         main_menu
         break;;
  esac
 done
 else
 echo
 echo "     There are no folders to unmount."
 main_menu
 return
 fi
 return
}
 my_umount
break
             my10
             break ;;
         4 ) clear
             main_menu 
             break ;;
         5 ) clear
             break ;;
         *) echo "Enter the number corresponding to the Menu items: Mounting images" ;;
    esac
done
return
}
my10
break ;;
         5) clear
            my3(){
            echo
            echo "      Menu: Unpacking .dat"
            echo
select img in "Unpacking.dat" "Unpacking .dat from the last used folder" "Exit to the main Menu" "Exit"; do
case $REPLY in 
         1 ) clear
             cd
             echo 
             echo "..Go to the folder where the files are located: \".dat\" and \".transfer.list\", for example: cd /sdcard"
             my_d()
{
 read b && $b
 if [ $(echo $?) -eq 0 ]; then
 clear
 dir_dat=/data/local/binary
 ndd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!') && echo "$ndd" > "$dir_dat"/last.txt
 v=$(busybox find . -maxdepth 1 -name '*.new.dat' 2> /dev/null | busybox sed 's!./!!')

 set -- $v

 if [ ! -z "$v" ]; then
 free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "...We are in the folder: /$ndd"
 echo "...В /${ndd} freely: $free_space"
 if [ "$free_space" != "$free_data" ]; then
 echo "...В /data freely: $free_data"
 fi
 echo
 echo ".....Select file to unzip:"
 echo
 select menu in $v "Exit to the main Menu" "Completion of work"; do
 case $REPLY in
                   [1-9]*) i="$#"
                      j="$#"
                      let i=i+1
                      let j=j+2
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
       if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         #nd=data/local/UnpackerSystem
         . ${dir}/unpack_dat
         main_menu
         return
         break
       elif [ "$REPLY" -eq "$i" ]; then
         clear
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$j" ]; then
         clear
        return
        break
       else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my3
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my3
         return
         break;;
  esac
 done
 else
 echo
 echo ".....There are no \".dat\" images to unpack in the \"/$ndd\" folder."
 echo
 main_menu
return
 fi
echo
else
echo
echo ".....error: Error moving to directory!"
echo
echo "Please enter the directory correctly!"
echo
my_d
return
fi
return
}
my_d
 break ;;
           2 ) clear
  my_last_dat()
{         
 v=$(busybox find . -maxdepth 1 -name '*.new.dat' 2> /dev/null | busybox sed 's!./!!')

 set -- $v

if [ ! -z "$v" ]; then
free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "...We are in the folder: /$ndd"
 echo "...В /${ndd} freely: $free_space"
 if [ "$free_space" != "$free_data" ]; then
 echo "...В /data freely: $free_data"
 fi
 echo
 echo ".....Select file to unzip:"
 echo
select menu in $v "Exit to the main Menu" "Completion of work"; do
case $REPLY in
                  [1-9]*) i="$#"
                      j="$#"
                      let i=i+1
                      let j=j+2
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
       if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         #nd=data/local/UnpackerSystem
         . ${dir}/unpack_dat
         main_menu
         return
         break
       elif [ "$REPLY" -eq "$i" ]; then
         clear
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$j" ]; then
         clear
        return
        break
       else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my3
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my3
         return
         break;;
  esac
 done
 else
 echo
 echo ".....There are no \".dat\" images to unpack in the \"/$ndd\" folder."
 echo
 main_menu
return
 fi
 return
}

  dir_dat=/data/local/binary
 last_dir="$(busybox cat /data/local/binary/last.txt 2> /dev/null | busybox sed 's!^/!!')" 
       if [ ! -z "$last_dir" -a -d /"$last_dir" ]; then
       ndd="$last_dir"
       cd /"$ndd"
       my_last_dat
       return
       else
       echo
       echo ".....The last used folder has not yet been defined!"
       echo
       main_menu
       fi
       break ;;
         3 ) clear
             main_menu
             break ;;
         4 ) clear
             break ;;
         *) clear
            echo
            echo ".....Enter the number corresponding to this Menu."
             my3
            break ;;      
    esac
done
return
}
my3
break ;;
         6) clear

qqq_br()
       {
       free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo -e "\033[33;1m...В /${nb} freely: $free_space \033[0m"
 if [ "$free_space" != "$free_data" ]; then
 echo -e "\033[33;1m...В /data freely: $free_data \033[0m"
 fi
return
}

            my_br(){
            echo
            echo "      Menu: Unpacking .br"
            echo
select img in "Unpack .br" "Unpacking .br from the last used folder" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
              cd
             echo 
             echo "...Go to the folder where the files are located: \".br\" and \".transfer.list\", for example: cd /sdcard"          
              my_b()
{
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nb=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!') && echo "$nb" > "$dir_dat"/last.txt
v=$(busybox find . -maxdepth 1 -name '*.new.dat.br' -type f 2> /dev/null | busybox sed 's!./!!')

set -- $v

if [ ! -z "$v" ]; then
free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "...We are in the folder: /$nb"
 echo "...В /${nb} freely: $free_space"
 if [ "$free_space" != "$free_data" ]; then
 echo "...В /data freely: $free_data"
 fi
 echo
 echo ".....Select file to unzip:"
 echo
select menu in $v "Unpack all images" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
                  [1-9]*) i="$#"
                      j="$#"
                      e="$#"
                      let i=i+1
                      let j=j+2
                      let e=e+3
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
       if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         . ${dir}/unpack_br
         main_menu
         return
         break
       elif [ "$REPLY" -eq "$i" ]; then
         clear
        for br in "$@"; do
        file=/"$nb"/"$br"
       . ${dir}/unpack_br
       qqq_br
       done 
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$j" ]; then
         clear
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$e" ]; then
         clear
        return
        break
       else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_br
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_br
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no \".br\" images to unpack in the \"/$nb\" folder."
 echo
 main_menu
return
 fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
my_b
return
fi
return
}
my_b
              break ;;
         2 ) clear
 my_last_br()
{
 
v=$(busybox find . -maxdepth 1 -name '*.new.dat.br' -type f 2> /dev/null | busybox sed 's!./!!')

set -- $v

if [ ! -z "$v" ]; then
free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "...We are in the folder: /$nb"
 echo "...В /${nb} freely: $free_space"
 if [ "$free_space" != "$free_data" ]; then
 echo "...В /data freely: $free_data"
 fi
 echo
 echo ".....Select file to unzip:"
 echo
select menu in $v "Unpack all images" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
                  [1-9]*) i="$#"
                      j="$#"
                      e="$#"
                      let i=i+1
                      let j=j+2
                      let e=e+3
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
       if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         #nd=data/local/UnpackerSystem
         . ${dir}/unpack_br
         main_menu
         return
         break
       elif [ "$REPLY" -eq "$i" ]; then
         clear
      for br in "$@"; do
        file=/"$nb"/"$br"
       . ${dir}/unpack_br
       qqq_br
       done 
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$j" ]; then
         clear
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$e" ]; then
         clear
        return
        break
       else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_br
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_br
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no \".br\" images to unpack in the \"/$nb\" folder."
 echo
 main_menu
return
 fi
}

  dir_dat=/data/local/binary
 last_dir="$(busybox cat /data/local/binary/last.txt 2> /dev/null | busybox sed 's!^/!!')" 
       if [ ! -z "$last_dir" -a -d /"$last_dir" ]; then
       nb="$last_dir"
       cd /"$nb"
       my_last_br
       return
       else
       echo
       echo ".....The last used folder has not yet been defined!"
       echo
       main_menu
       fi
       break ;;
         3 ) clear
             main_menu
             break ;;
         4 ) clear
             break ;;
         *) clear
            echo
            echo ".....Enter the number corresponding to this Menu."
             my_br
            break ;;      
    esac
done
return
}
my_br
break ;;
         7) #Assembly .img start +++++++++++++++++

dir=/data/local/binary
cd /data/local/UnpackerSystem

 check_d()
{
 #cd /data/local/UnpackerSystem
 for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 return 0
 fi
 done
 return
}

qqq_space()
       {
       free_space="$(busybox df -h "$outdir" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 free_data="$(busybox df -h /data | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo -e "\033[33;1m...В $outdir freely: $free_space \033[0m"
 if [ "$free_space" != "$free_data" ]; then
 echo -e "\033[33;1m...В /data freely: $free_data \033[0m"
 fi
return
}
             pack_img_my()
{
b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Exit to the main Menu"; do
case $REPLY in
 [1-9]*) i="$#"

 let i=i+1

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
#nd=data/local/UnpackerSystem
          pack_d="$file"
          config="config/$pack_d"

                    size=111
                    set -- $size
                    file_size=${dir}/pack_img
         if [ -f ./"$config"/"$pack_d"*_avb.img ]; then
         file_sh=./"$config"/"$pack_d"*_pack_avb_sparse.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack_sparse.sh
          fi
                     if [ "$size_add" == "1" ]; then
                     my_size_add
                 else
                  my_size
                  fi
                 return
               break
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$i" ]; then
 clear
 main_menu
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_my
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_my
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for assembly."
 echo
 main_menu
 return
fi
return
}


pack_img_orig()
{
 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Exit to the main Menu"; do
case $REPLY in
 [1-9]*) i="$#"

 let i=i+1

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
#nd=data/local/UnpackerSystem
 pack_d="$file"
 config="config/$pack_d"
 

 size=100
 . ${dir}/pack_img
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$i" ]; then
 clear
 main_menu
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_orig
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_orig
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" there are no folders for assembly."
 echo
 main_menu
 return
fi
return
}

 pack_img_raw_orig()
{
 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Exit to the main Menu"; do
case $REPLY in
 [1-9]*) i="$#"

 let i=i+1

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
#nd=data/local/UnpackerSystem
 pack_d="$file"
 config="config/$pack_d"
 

 size=100
 . ${dir}/pack_img_raw
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$i" ]; then
 clear
 main_menu
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_raw_orig
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_raw_orig
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" there are no folders for assembly."
 echo
 main_menu
 return
fi
return
}

pack_img_raw_my()
{
b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Exit to the main Menu"; do
case $REPLY in
 [1-9]*) i="$#"

 let i=i+1

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
#nd=data/local/UnpackerSystem
          pack_d="$file"
          config="config/$pack_d"

                    size=111
                    set -- $size
                    file_size=${dir}/pack_img_raw
         if [ -f ./"$config"/"$pack_d"_avb.img ]; then
         file_sh=./"$config"/"$pack_d"_pack_avb.sh
        else
         file_sh=./"$config"/"$pack_d"_pack.sh
          fi
                     #my_size
           if [ "$size_add" == "1" ]; then
                     my_size_add
                 else
                  my_size
                  fi
                 return
               break
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$i" ]; then
 clear
 main_menu
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_raw_my
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_raw_my
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for assembly."
 echo
 main_menu
 return
fi
return
}

  pack_img_raw_new()
{

free_place
 #if [ "$erof" == "1" ]; then
 #cd /data/local/UnpackerSystem/erofs
 #elif [ "$erof" == "0" ]; then
 #cd /data/local/UnpackerSystem
 #fi

b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Collect all images" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
 [1-9]*) i="$#"       
        j="$#"
        e="$#"
        let i=i+1
        let j=j+2
        let e=e+3

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
#nd=data/local/UnpackerSystem
          pack_d="$file"
          config="config/$pack_d"
 
 size_orig="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
if busybox test "$size_orig" -le "10485760"; then
 get_add="8192"
  check_size_img
 #size_new="$(busybox expr "$size_orig" \* 109 / 105 / 4096 \* 4096)"
else
 get_add="1048576"
 check_size_img
 #size_new="$(busybox expr "$size_orig" \* 12 / 11 / 4096 \* 4096)"
  fi
                    size=111
                    set -- $size
                   r_size="$size_new"
                   set -- $r_size
                    file_size=${dir}/pack_img_raw
         if busybox test -s ./"$config"/"$pack_d"*_avb.img; then
         file_sh=./"$config"/"$pack_d"*_pack_avb.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack.sh
         busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
          fi
              . $file_size 
              main_menu
              return
              break
  elif [ "$REPLY" -eq "$i" ]; then
   clear
   for papka in "$@"; do
          if [ "$erof" == "0" ]; then
          erof="0"
          elif [ "$erof" == "1" ]; then
          erof="1"
          fi
          pack_d="$papka"
          config="config/$pack_d"
 
 size_orig="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
if busybox test "$size_orig" -le "10485760"; then
 get_add="8192"
  check_size_img
else
 get_add="1048576"
 check_size_img
  fi
                    size=111
                    set -- $size
                   r_size="$size_new"
                   set -- $r_size
                    file_size=${dir}/pack_img_raw
         if busybox test -s ./"$config"/"$pack_d"*_avb.img; then
         file_sh=./"$config"/"$pack_d"*_pack_avb.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack.sh
         busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
          fi
              . $file_size
              qqq_space
              sleep 2
done
          main_menu
              return
              break
  
 elif [ "$REPLY" -eq "$j" ]; then
 clear
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$e" ]; then
 clear
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_raw_new
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_raw_new
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for assembly."
 echo
 main_menu
 return
fi
return
}

  pack_img_new()
{
  free_place
  
  #if [ "$erof" == "1" ]; then
 #cd /data/local/UnpackerSystem/erofs
 #elif [ "$erof" == "0" ]; then
 #cd /data/local/UnpackerSystem
 #fi

 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Collect all images" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
 [1-9]*) i="$#"
        j="$#"
        e="$#"
        let i=i+1
        let j=j+2
        let e=e+3

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
#nd=data/local/UnpackerSystem
          pack_d="$file"
          config="config/$pack_d"
 
 size_orig="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
if busybox test "$size_orig" -le "10485760"; then
 get_add="8192"
  check_size_img
 #size_new="$(busybox expr "$size_orig" \* 109 / 105 / 4096 \* 4096)"
else
 get_add="1048576"
 check_size_img
 #size_new="$(busybox expr "$size_orig" \* 12 / 11 / 4096 \* 4096)"
  fi
                    size=111
                    set -- $size
                   r_size="$size_new"
                   set -- $r_size
                    file_size=${dir}/pack_img
         if busybox test -s ./"$config"/"$pack_d"*_avb.img; then
         file_sh=./"$config"/"$pack_d"*_pack_avb_sparse.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack_sparse.sh
         busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
          fi
              . $file_size
              main_menu
              return
              break
 elif [ "$REPLY" -eq "$i" ]; then
 for papka in "$@"; do
          clear
          if [ "$erof" == "0" ]; then
          erof="0"
          elif [ "$erof" == "1" ]; then
          erof="1"
          fi
          
          pack_d="$papka"
          config="config/$pack_d"
 
 size_orig="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
if busybox test "$size_orig" -le "10485760"; then
 get_add="8192"
  check_size_img
 #size_new="$(busybox expr "$size_orig" \* 109 / 105 / 4096 \* 4096)"
else
 get_add="1048576"
 check_size_img
 #size_new="$(busybox expr "$size_orig" \* 12 / 11 / 4096 \* 4096)"
  fi
                    size=111
                    set -- $size
                   r_size="$size_new"
                   set -- $r_size
                    file_size=${dir}/pack_img
         if busybox test -s ./"$config"/"$pack_d"*_avb.img; then
         file_sh=./"$config"/"$pack_d"*_pack_avb_sparse.sh
        else
         file_sh=./"$config"/"$pack_d"*_pack_sparse.sh
         busybox sed -e "s!-l [0-9]*!-l "$r_size"!" $file_sh > "$config"/"$pack_d"_gsize.sh
          fi
              . $file_size
              qqq_space
              sleep 2
done
          main_menu
              return
              break
 elif [ "$REPLY" -eq "$j" ]; then
 clear
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$e" ]; then
 clear
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_new
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_new
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for assembly."
 echo
 main_menu
 return
fi
return
}

pack_img_erofs()
{

 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Collect all images" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
 [1-9]*) i="$#"
        j="$#"
        e="$#"
        let i=i+1
        let j=j+2
        let e=e+3

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
          pack_d="$file"
          config="config/$pack_d"
   . ${dir}/pack_img_erofs
   unset ext_erof
              main_menu
              return
              break
 elif [ "$REPLY" -eq "$i" ]; then
 for papka in "$@"; do
          clear
          if [ "$erof" == "0" ]; then
          erof="0"
          elif [ "$erof" == "1" ]; then
          erof="1"
          fi
          
          pack_d="$papka"
          config="config/$pack_d"
 
  . ${dir}/pack_img_erofs
  unset ext_erof
              qqq_space
              sleep 2
done
          main_menu
              return
              break
 elif [ "$REPLY" -eq "$j" ]; then
 clear
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$e" ]; then
 clear
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_erofs
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_erofs
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for assembly."
 echo
 main_menu
 return
fi
return
}

pack_img_e2fs()
{

 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select a folder for assembly:"
 echo
 select menu in $b "Collect all images" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
 [1-9]*) i="$#"
        j="$#"
        e="$#"
        let i=i+1
        let j=j+2
        let e=e+3

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
          config_e2fs="1"
          set -- $config_e2fs
          pack_d="$file"
          config="config/$pack_d"
   . ${dir}/pack_img_e2fsdroid
          unset config_e2fs
              main_menu
              return
              break
 elif [ "$REPLY" -eq "$i" ]; then
 for papka in "$@"; do
          clear
          #if [ "$erof" == "0" ]; then
          #erof="0"
          #elif [ "$erof" == "1" ]; then
          #erof="1"
          #fi
          config_e2fs="1"
          set -- $config_e2fs
          pack_d="$papka"
          config="config/$pack_d"
 
  . ${dir}/pack_img_e2fsdroid
          unset config_e2fs
              qqq_space
              sleep 2
done
          main_menu
              return
              break
 elif [ "$REPLY" -eq "$j" ]; then
 clear
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$e" ]; then
 clear
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_e2fs
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 pack_img_e2fs
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders available for assembly."
 echo
 main_menu
 return
fi
return
}


            my5(){
            clear
            check_d
   if [ $(echo $?) -eq 0 ]; then
            echo
            echo "      Menu: Assembly .img"
            echo
select img in "Collect .img(sparse)" "Collect .img(raw)" "Assembly super.img" "Write to fs_config" "Information about the size of the folder for assembly" "Restoring symlinks" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
             
             sparse_s()
             {
             echo
  select img in "Collect .img(sparse) with original size" "Collect .img(sparse) with image size input" "Collect .img(sparse) with build folder size" "Collect .img(sparse) in ro with shared_blocks" "Collect .img(sparse)(erofs in ext4)" "Collect .img(sparse)(erofs in erofs)" "Collect .img(sparse)(ext4 in erofs)" "Collect .img(sparse)(f2fs in ext4)" "Collect .img(sparse)(ubifs)" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
                1 ) clear
                    erof="0"
                    set -- $erof
                     nn
                     pack_img_orig
                      break ;;
                2 ) clear
                    erof="0"
                    set -- $erof
                    nn
                    pack_img_my
                     break ;;
                3 ) clear
                     erof="0"
                    set -- $erof
                    nn
                    pack_img_new
                     break ;;
                 4 ) clear
                    nn
                    sparse_e2fs="1"
                    set -- $sparse_e2fs
                    #config_e2fs="1"
                    #set -- $config_e2fs
                    erof="0"
                    set -- $erof
                     pack_img_e2fs
                     break ;;    
                 5 ) clear
                    erof="1"
                    set -- $erof
                     nn
     mkdir /data/local/UnpackerSystem/erofs 2> /dev/null
  cd /data/local/UnpackerSystem/erofs
                     pack_img_new
                     break ;;
                 6 )  clear
                    erof="0"
                    set -- $erof
                    sparse_erof="1"
                    set -- $sparse_erof
                    ext_erof="0"
                    set -- $ext_erof
                    nn
     mkdir /data/local/UnpackerSystem/erofs 2> /dev/null
  cd /data/local/UnpackerSystem/erofs
                     pack_img_erofs
                    break ;;
                7 )    
                    clear
                    erof="0"
                    set -- $erof
                    sparse_erof="1"
                    set -- $sparse_erof
                    ext_erof="1"
                    set -- $ext_erof
                    nn
     mkdir /data/local/UnpackerSystem 2> /dev/null
  cd /data/local/UnpackerSystem
                     pack_img_erofs
                    break ;;
                 8 ) clear
                    erof="2"
                    set -- $erof
                    nn
     mkdir /data/local/UnpackerSystem/f2fs 2> /dev/null
  cd /data/local/UnpackerSystem/f2fs
                     pack_img_new
                    break ;;     
                 9 ) clear
     [ -d /data/local/UnpackerSystem/ubifs-root ] && cd /data/local/UnpackerSystem/ubifs-root
file_build="$(find -maxdepth 1 -name "*.sh" -type f)"
file_ini="$(find -maxdepth 1 -name "*.ini" -type f)"
pap_raw="$(busybox cat ubi_name.txt)"
part_exten="$(busybox cat part_exten.txt)"

if [ -s "$file_build" -a -s "$file_ini" ]; then
echo
echo ".....Assembly ubifs(sparse): ${pap_raw}.sparse.${part_exten}..."
#echo
"$file_build"
if [ $(echo $?) -eq 0 ]; then

cd ../
if [ -s "${pap_raw}.new.${part_exten}" ]; then
img2simg "${pap_raw}.new.${part_exten}" "${pap_raw}.sparse.${part_exten}" && busybox rm -f "${pap_raw}.new.${part_exten}"
if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Successfully completed!"
 echo
 else
 echo
 echo ".....Error, error during assembly!"
 echo
 fi
 else
 echo
 echo ".....Error, no file to convert!"
 echo
fi
else
 echo
 echo ".....Error, error during assembly!"
 echo
fi
else
echo
 echo ".....Error, no files to build!"
 echo
fi    
                    main_menu
                    break ;;   
                 10 ) clear
                    main_menu
                    break ;;
                 11 ) clear
                     break ;;
                * ) clear
            echo
            echo "      Enter the numbers corresponding to Menu."
            echo
            sparse_s
              break ;;
esac
done
return
}
sparse_s
break ;;
         2 ) clear
             raw_s()
{
             echo
select img in "Collect .img(raw) with original size" "Collect .img(raw) with image size input" "Collect .img(raw) with build folder size" "Collect .img(raw) in ro with shared_blocks" "Collect .img(raw)(erofs in ext4)" "Collect .img(raw)(erofs in erofs)" "Collect .img(raw)(ext4 in erofs)" "Collect .img(raw)(f2fs in ext4)" "Collect .img(raw)(ubifs)" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
                1 ) clear
                    nn
                    erof="0"
                    set -- $erof
                    pack_img_raw_orig
                      break ;;
                2 ) clear
                    nn
                    erof="0"
                    set -- $erof
                     pack_img_raw_my
                     break ;;
                3 ) clear
                    nn
  
                    erof="0"
                    set -- $erof
                     pack_img_raw_new
                     break ;;
                4 ) clear
                    nn
                    sparse_e2fs="0"
                    set -- $sparse_e2fs
                    #config_e2fs="1"
                    #set -- $config_e2fs
                    erof="0"
                    set -- $erof
                     pack_img_e2fs
                     break ;;    
                5 ) clear
                    erof="1"
                    set -- $erof
                    nn
     mkdir /data/local/UnpackerSystem/erofs 2> /dev/null
  cd /data/local/UnpackerSystem/erofs
                     pack_img_raw_new
                    break ;;
                6 )     clear
                    erof="0"
                    set -- $erof
                    sparse_erof="0"
                    set -- $sparse_erof
                    ext_erof="0"
                    set -- $ext_erof
                    nn
     mkdir /data/local/UnpackerSystem/erofs 2> /dev/null
  cd /data/local/UnpackerSystem/erofs
                     pack_img_erofs
                    break ;;
                7 )     clear
                    erof="0"
                    set -- $erof
                    sparse_erof="0"
                    set -- $sparse_erof
                    ext_erof="1"
                    set -- $ext_erof
                    nn
     mkdir /data/local/UnpackerSystem 2> /dev/null
  cd /data/local/UnpackerSystem
                     pack_img_erofs
                    break ;;
                8 ) clear
                    erof="2"
                    set -- $erof
                    nn
     mkdir /data/local/UnpackerSystem/f2fs 2> /dev/null
  cd /data/local/UnpackerSystem/f2fs
                     pack_img_raw_new
                     #pack_img_raw_orig
                    break ;;      
                9 ) clear
   [ -d /data/local/UnpackerSystem/ubifs-root ] && cd /data/local/UnpackerSystem/ubifs-root
file_build="$(find -maxdepth 1 -name "*.sh" -type f)"
file_ini="$(find -maxdepth 1 -name "*.ini" -type f)"
pap_raw="$(busybox cat ubi_name.txt)"
part_exten="$(busybox cat part_exten.txt)"
if [ -s "$file_build" -a -s "$file_ini" ]; then
echo
echo
echo ".....Assembly ubifs(raw): ${pap_raw}.new.${part_exten}..."
"$file_build"
if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Successfully completed!"
 echo
 else
 echo
 echo ".....Error, error during assembly!"
 echo
fi
else
 echo
 echo ".....Error, no files to build!"
 echo
fi
                    main_menu
                    break ;;    
                10 ) clear
                    main_menu
                    break ;;
                11 ) clear
                    break ;;
                * ) clear
            echo
            echo "      Enter the numbers corresponding to Menu." 
              raw_s
              break ;;
  esac
 done
return
}
raw_s
break ;;
         3) clear
             echo
             echo ".....Check if the required images are in the folder /data/local/UnpackerSuper"
             echo
select img in "Collect super.img(sparse)" "Collect super.img(raw)" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
                1 ) clear
                    spars=1
                   . /data/local/binary/pack_super_img
                    main_menu
                     break ;;
                2 ) clear
                    spars=0
                   . /data/local/binary/pack_super_img
                    main_menu
                     break ;;
                3 ) clear
                    main_menu
                    break ;;
                4 ) clear
                    break ;;
                 *) echo "Enter the number corresponding to the items in this Menu."
  esac
done
break ;;
         4) clear
             echo
             echo ".....Add folders or files to the unpacked image..."
             echo
select img in "Recording" "Exit to the main Menu"; do
case $REPLY in
                1 ) clear
                   . /data/local/binary/a_atr
                     break ;;
                2 ) clear
                    main_menu
                    break ;;
                 *) echo "Enter the number corresponding to the items in this Menu."
  esac
done
break ;;  
          5 ) clear
            cd /data/local/UnpackerSystem
             size_papka()
{
 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

set -- $b

if [ ! -z "$b" ]; then
echo
echo ".....Select folder:"
echo
select menu in $b "Exit to the main Menu" "Completion of work"; do
case $REPLY in
                 [1-9]*) i="$#"
                      j="$#"
                      let i=i+1
                      let j=j+2
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
       if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         pack_d="$file"
         config="config/$pack_d"
 
 size_orig="$(busybox expr $(busybox du -s "$pack_d" | busybox awk '{ print $1 }') \* 1024)"
 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
if busybox test "$size_orig" -le "10485760"; then
 get_size="0"
 get_add="8192"
  check_size_img
else
 get_size="0"
 get_add="1048576"
 check_size_img
  fi

 size_real="$(busybox cat "$config"/"$pack_d"_size.txt)"
 echo
 echo "       -----------------------------"
 echo "       -----------------------------"
 echo
 echo ".....Current size for image assembly:"  
 echo "     $size_real byte"
 echo
 echo ".....Folder size \"$pack_d\":"
 echo "     $size_orig byte"
 echo
 echo ".....Approximate minimum size with which the image will be assembled:"
 echo "     $size_new byte"
 echo
         main_menu
         return
         break
       elif [ "$REPLY" -eq "$i" ]; then
         clear
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$j" ]; then
         clear
        return
        break
       else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         size_papka
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         size_papka
         return
         break;;
  esac
  done
 else
 echo
 echo ....."В \"$PWD\" there are no folders for assembly."
 echo
 main_menu
 return
 fi
return
}
 size_papka
   break ;;

          6 ) clear
             cd /data/local/UnpackerSystem
             symlink()
{
 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if [ -f "config/"$a"/"$a"_file_contexts" ]; then
 echo "$a"
 fi
 done | busybox sort -f)

 set -- $b

 if [ ! -z "$b" ]; then
 echo
 echo ".....Select folder for recovery:"
 echo
 select menu in $b "Exit to the main Menu"; do
case $REPLY in
 [1-9]*) i="$#"

 let i=i+1

 file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
 if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
    clear
    pack_d="$file"
    config="config/$pack_d"
  if busybox test -s "$config"/"$pack_d"_sim.tar; then
           busybox tar -xf "$config"/"$pack_d"_sim.tar
if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Successfully restored!"
 echo
 else
 echo
 echo ".....Error during recovery!"
 echo
 fi
 else
 echo
 echo ".....No archive saved for recovery!"
 echo
 fi
 main_menu
 return
 break
 elif [ "$REPLY" -eq "$i" ]; then
 clear
 main_menu
 return
 break
 else
 clear
 echo
 echo " Enter the numbers corresponding to Menu."
 symlink
 return
 break
 fi
 break;;
 *) clear
 echo
 echo " Enter the numbers corresponding to Menu."
 symlink
 return
 break;;
 esac
 done
 else
 clear
 echo
 echo ....."В \"$PWD\" no folders for recovery."
 echo
 main_menu
 return
fi
return
}
 symlink
    break ;;    
         7 ) clear
             main_menu
             break ;;
         8 ) clear
             break ;;
         *) echo "Enter the number corresponding to the items Menu: Assembly sparse.img." ;;
    esac
done
else
echo
echo ....."В \"$PWD\" there are no folders for assembly."
echo
main_menu
return
fi
return
}
 my5
    break ;;          
              #End of function Assembly .img

          8) clear
             my6(){
             file_size=${dir}/pack_img_dat
             check_dat="222"
             echo
             echo "      Menu: Assembly и Convert в .dat"
             echo
select img in "Collect .img -> .dat" "Collect .img with size input -> .dat" "Collect .img with size of folder for collection -> .dat" "Convert \".img\" to \".dat\"" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
             erof="0"
             set -- $erof
              nn
              pack_dat
              break ;;
         2 )
             clear
              erof="0"
              set -- $erof
              nn
              pack_dat_my
              break ;;
         3 ) clear
             erof="0"
             set -- $erof
             nn
             pack_dat_new
              break ;;
         4 )  clear
              my_k(){
             echo 
             echo "..Go to the folder where the file \".img\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }')
v=$(for sparse in $(busybox find . -maxdepth 1 -name '*.img' -type f 2> /dev/null); do
if [ ! -z "$(busybox hexdump -C -n 20000 "$sparse" | busybox grep -Eo '3a ff 26 ed|30 50 4c 41')" -o ! -z "$(busybox hexdump -C -n 2000 "$sparse" | busybox awk '/00000430/ { print $10$11 }' | busybox grep -o "53ef")" -o ! -z "$(busybox hexdump -C -n 2000 "$sparse" | busybox awk '/00000400/ { print $2$3$4$5 }' | busybox grep -o "e2e1f5e0")" ]; then
echo "$sparse"
fi
done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file to convert to \".dat\":"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
           br_check="false"
         . ${dir_dat}/konvert_img_dat
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_k
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_k
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no images \".img\" in the \"$nd\" folder to convert."
 echo
 main_menu
return
 fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
my_k
return
fi
return
}
 my_k
      break ;;
         5 ) clear
             main_menu
             break ;;
         6 ) clear
             break ;;
         *) echo "Enter the number corresponding to the Menu items: Assembly and convert to .dat." ;;
    esac
done
return
}
 my6
     break ;;
         9) clear
            my7(){
            file_size=${dir}/pack_img_br
            check_dat="222"
            echo
            echo "      Menu: Assembly and conversion to .br"
            echo
select img in "Collect .img -> .br" "Collect .img with size input -> .br" "Collect .img with size of folder for assembly -> .br" "Convert .img to .br" "Convert .dat to .br" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
          1 ) clear
              erof="0"
              set -- $erof
              nn
             
             pack_dat
             break ;;
         2 ) clear
             erof="0"
             set -- $erof
              nn
             pack_dat_my
             break ;;
         3 ) clear
             erof="0"
             set -- $erof
              nn
             pack_dat_new
             break ;; 
         4 ) clear
             my_imgbr()
             {
             echo 
             echo "..Go to the folder where the file \".img\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }')
v=$(for sparse in $(busybox find . -maxdepth 1 -name '*.img' -type f 2> /dev/null); do
if [ ! -z "$(busybox hexdump -C -n 20000 "$sparse" | busybox grep -Eo '3a ff 26 ed|30 50 4c 41')" -o ! -z "$(busybox hexdump -C -n 2000 "$sparse" | busybox awk '/00000430/ { print $10$11 }' | busybox grep -o "53ef")" -o ! -z "$(busybox hexdump -C -n 2000 "$sparse" | busybox awk '/00000400/ { print $2$3$4$5 }' | busybox grep -o "e2e1f5e0")" ]; then
echo "$sparse"
fi
done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file to convert:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         br_check="true"
       . ${dir_dat}/konvert_img_dat
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_imgbr
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_imgbr
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no \".img\" images in the \"$nd\" folder to convert."
 echo
 main_menu
return
 fi
echo
else
echo
echo ".....error: Error moving to directory!"
echo
echo ".....Please enter the directory correctly!"
echo
my_imgbr
return
fi
return
}
 my_imgbr
  break ;;
  
         5 ) clear
             my_kbr(){
             
             echo 
             echo "..Go to the folder where the file \".dat\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }')
v=$(busybox find . -maxdepth 1 -name '*.new.dat' -type f 2> /dev/null | busybox sed 's!./!!')

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file to convert:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
       . ${dir_dat}/konvert_dat_br
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         my_kbr
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         my_kbr
         return
         break;;
  esac
 done
 else
 echo
 echo ....."There are no \".dat\" images to convert in the \"$nd\" folder."
 echo
 main_menu
return
 fi
echo
else
echo
echo ".....error: Error moving to directory!"
echo
echo ".....Please enter the directory correctly!"
echo
my_kbr
return
fi
return
}
 my_kbr
  break ;;
         6 ) clear
             main_menu
             break ;;
         7 ) clear
             break ;;
         *) echo "Enter the number corresponding to the Menu items: Convert new.dat to .br" ;;
    esac
done
return
}
my7
break ;;
          10) clear
             my8(){
             echo 
             echo "      Menu: Convert sparse > raw; raw > sparse"
             echo
select img in "Convert .img(raw) в .img (sparse)" "Convert .img(sparse) в .img(raw)" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
             konv_img(){
             echo 
             echo "..Go to the folder where the file \".img(raw)\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
#v=$(busybox find . -maxdepth 1 -name 'vendor*.img' -type f -o -name 'system*.img' -type f | busybox sed 's!./!!')

 #v=$(for raw in $(busybox find . -maxdepth 1 -name 'vendor*.img' -type f -o -name 'system*.img' -type f 2> /dev/null); do
 #if [ -z "$(busybox hexdump -C -n 4 "$raw" | busybox grep '3a ff 26 ed')" ]; then
 #echo "$raw"
 #fi
 #done)

 v=$(for raw in $(busybox find -maxdepth 1 -name '*.img' -type f | busybox sed 's!./!!'); do
    if [ -z "$(busybox hexdump -C -n 2000 "$raw" | busybox grep -E '3a ff 26 ed')" -a ! -z "$(busybox hexdump -C -n 2000 "$raw" | busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" ]; then

       echo "$raw"
  elif [ -z "$(busybox hexdump -C -n 2000 "$raw" | busybox grep '3a ff 26 ed')" -a ! -z "$(busybox hexdump -C -n 20000 "$raw" | busybox grep "30 50 4c 41")" ]; then
       echo "$raw"
  elif [ -z "$(busybox hexdump -C -n 2000 "$raw" | busybox grep '3a ff 26 ed')" -a ! -z "$(busybox hexdump -C -n 2000 "$raw" | busybox grep -o "e2 e1 f5 e0")" ]; then
       echo "$raw"
  elif [ -z "$(busybox hexdump -C -n 2000 "$raw" | busybox grep '3a ff 26 ed')" -a ! -z "$(busybox hexdump -C -n 2000 "$raw" | busybox grep -o "10 20 f5 f2")" ]; then
       echo "$raw"
     fi
     done | busybox sort -f)

 set -- $v

 if [ ! -z "$v" ]; then
 echo
 echo "...We are in the folder: /$nd"
 echo "...Showing only \"raw\" images"
 free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo "...В /${nd} freely: $free_space"
 echo

 echo ".....Select file to convert to \"sparse\":"
 echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
       . ${dir_dat}/konvert_raw_sparse
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         konv_img
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         konv_img
         return
         break;;
  esac
 done
 else
 echo
 echo ..."There are no raw images to convert in the \"/$nd\" folder."
 echo
 main_menu
return
 fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
konv_img
return
fi
return
}
  konv_img
      break ;;
         2 ) clear
             konv_img(){
             echo 
             echo "..Go to the folder where the file \".img(sparse)\" is located, for example: cd /sdcard:"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
v=$(for sparse in $(busybox find . -maxdepth 1 -name '*.img' -type f 2> /dev/null); do
if [ ! -z "$(busybox hexdump -C -n 2000 "$sparse" | busybox grep '3a ff 26 ed')" ]; then
echo "$sparse"
fi
done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
 echo
 echo "...We are in the folder: /$nd"
 echo "...Showing only \"sparse\" images"
 free_space="$(busybox df -h "$PWD" | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo "...В /${nd} freely: $free_space"
 echo
 echo ".....Select file to convert to \"raw\":"
 echo
 select menu in $v "Exit to the main Menu"; do
case $REPLY in
    [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
       . ${dir_dat}/konvert_sparse_raw
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         konv_img
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         konv_img
         return
         break;;
  esac
 done
 else
 echo
 echo ..."There are no sparse images for conversion in the \"/$nd\" folder."
 echo
 main_menu
return
 fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
konv_img
return
fi
return
}
   konv_img
       break ;;
         3 ) clear
             main_menu
             break ;;
         4 ) clear
             break ;;
         *) echo "Enter the number corresponding to the Menu items: Convert sparse > raw; raw > sparse" ;;
    esac
done
return
}
my8
break ;;
         11) clear
             my2()
{
            echo
            echo "      Menu: Other tools"
            echo
           
select img in "Actions with AVB structure" "Convert .sin -> .img" "Convert .lz4|.zst|.xz|.lzma" "Glue image from firmware under Qfil" "Split super.img into parts" "Extracting images from payload.bin" "Extracting images from UPDATE.APP" "Creating an image from the memory block of the current firmware" "Unpacking(Convert) .ozip" "Creating tar.md5" "Unpacking firmware .img" "Unpacking firmware .ofp|.ops" "Unpacking firmware .pac" "Exit to the main Menu" "Completion of work"; do
case $REPLY in
          1 ) clear
              read_avb()
              {
              echo
              select img in "Patch vbmeta" "Viewing the structure of the AVB file" "Extracting the public key of the AVB signature" "Creating your own AVB signature key" "Replacing the public key in the image" "Signing boot(recovery).img with key selection" "Exit to the main Menu" "Completion of work"; do
 case $REPLY in
          1 ) clear
          
          pvbm()
 {
 clear
 echo
 echo ".....Looking for values ​​for the patch..."
 
 true_vb()
{
 tru="$(avbtool info_image --image "$file" | busybox awk '/Flags:/ NR == 1 {if($2 == 3) { print $2 }}')"
 rolbak="$(avbtool info_image --image "$file" | busybox awk '/Rollback Index:/ NR == 1 {if($3 == 0) { print $3 }}')"
 return
}
 #true_vb

 #if [ "$tru" != 3 -o "$rolbak" != 0 ]; then
 real_nd="$(echo /"$nd" | busybox grep -o "/dev/block")"
 if [ -z "$real_nd" ]; then

 file_name="$(echo "$file" | busybox sed 's!.img$!!')"
 file_orig="$file"
 file_path="${file_name}_path.img"
 busybox cp -f "$file_orig" "$file_path"
 #python39 /data/local/binary/bin_system/int.py "$file" "7b" "03"
 #echo '7b: 03' | xxd -r - "$file"
 else
 file_orig="$file"
 file_path="$file"
 fi

 #for vb in "78: $num_path" "74: 00000000" "7c: 00000000"; do
 
 echo "78: $num_path" | /data/local/binary/xxd -r - "$file_path"
 
 #done

 if [ $(echo $?) -eq 0 ]; then
 file="$file_path"
 true_vb

 #if [ "$tru" == 3 -a "$rolbak" == 0 ]; then
 if [ -z "$real_nd" ]; then
 echo
 echo ".....Successfully patched /"$nd"/"$file_orig" -> /"$nd"/"$file_path""
 echo ".....Patch status:  $file_vbm"
 echo
 else
 echo
 echo ".....Successfully patched /"$nd"/"$file_orig""
 echo ".....Patch status:  $file_vbm"
 echo
 fi
 else
 echo
 echo ".....Error during patch /"$nd"/"$file""
 echo
 #fi
 fi
 #else
 #echo
 #$echo ".....File /"$nd"/"$file" already patched!"
 #echo
 #fi
}
             vbmeta()
{
              echo
              echo "..Go to the folder where the file \"vbmeta.img\" is located, for example: cd /sdcard"
 read b && $b
 if [ $(echo $?) -eq 0 ]; then
 clear
 nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')

 v=$(for a in $(busybox find . -maxdepth 1 -name "*.img" -type f -o -name "vbmeta*" | busybox sed 's!./!!'); do
    
  if [ ! -z "$(busybox hexdump -C -n 20 "$a" 2> /dev/null | busybox grep -o "41 56 42 30")" ]; then
       echo "$a"
     fi
     done | busybox sort -f)

 set -- $v

 if [ ! -z "$v" ]; then
 echo
 echo ".....Select file for patch:"
 echo
 select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 #clear
 
 
 choice_vb()
{
 clear
 v=$(echo "Disable_dm_verity" "Disable_dm_verification" "Disable_dm_verity+Disable_dm_verification")

 set -- $v
 echo
 echo ".....Select patch for vbmeta:"
 echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file_vbm=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file_vbm" -a "$REPLY" -lt "$i" ]; then
if [ "$file_vbm" == "Disable_dm_verity" ]; then
 num_path="00000001"
 pvbm
elif [ "$file_vbm" == "Disable_dm_verification" ]; then
 num_path="00000002"
 pvbm
elif [ "$file_vbm" == "Disable_dm_verity+Disable_dm_verification" ]; then
 num_path="00000003"
 pvbm
fi
       main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
        clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         choice_vb
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         choice_vb
         return
         break;;
  esac
 done
return
}
 choice_vb
   #main_menu
        return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         vbmeta
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         vbmeta
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."There are no vbmeta files for the patch in the \"/$nd\" folder."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
vbmeta
return
fi
return
}
 vbmeta
  break ;;
          2 ) clear
              vbmeta_info()
{
              echo
              echo "..Go to the folder where the file \"*.img\" is located, for example: cd /sdcard"
 read b && $b
 if [ $(echo $?) -eq 0 ]; then
 clear
 echo
 echo ".....Search files..."
 nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')

 v=$(for a in $(busybox find -maxdepth 1 -name "*.img" -o -name '*.win' -type f -o -name "vbmeta*" -a -type l | busybox sed 's!./!!'); do
    
  #if [ ! -z "$(busybox hexdump -C -n 20 "$a" 2> /dev/null | busybox grep -o "41 56 42 30")" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox grep '3a ff 26 ed')" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox grep -o '41 4e 44 52 4f 49 44 21')" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox grep -o 'e2 e1 f5 e0')" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox grep -o '10 20 f5 f2 ')" ]; then
       echo "$a"
     #fi
     done | busybox sort -f)

 set -- $v

 if [ ! -z "$v" ]; then
 clear
 echo
 echo ".....Select file:"
 echo
 select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then

 t="     File: /$nd/$file"
 g=${#t}
 ggg="$(busybox expr "$g" - 6)"
 gg="$(busybox seq -s- "$ggg" | busybox tr -d '[:digit:]')"
 #gg1="$(busybox seq -s- 28 | busybox tr -d '[:digit:]')"
 clear
 echo
 echo
 echo "    $gg"
 echo "$t"  
 echo "    $gg"
 #echo "     ------------------------------"
 #echo "     File: /"$nd"/"$file""
 #echo "     ------------------------------"
 echo
f_avb=/data/local/binary/avb.txt
 avbtool info_image --image "$file" &> "$f_avb"
 if [ ! -z "$(busybox cat "$f_avb" | busybox grep -o "Minimum libavb version:")" ]; then
 busybox cat "$f_avb"
 else
 echo "     AVB structure not found!"
 fi
 echo
 echo "    $gg"
 echo
 busybox rm -f "$f_avb"
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         vbmeta_info
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         vbmeta_info
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."В папке \"/$nd\" No Fileов \"*.img\""
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
vbmeta_info
return
fi
return
}
 vbmeta_info
   break ;;
   
   
          3 ) clear
              unset aik_mob
              extract_key()
{
              echo
              echo "..Go to the folder where File \"*.img\" is located, for example: cd /sdcard"
 read b && $b
 if [ $(echo $?) -eq 0 ]; then
 clear
 echo
 echo ".....Search files..."
 nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')

 v=$(for a in $(busybox find . -maxdepth 1 -name "*.img" -o -name "*.win" -type f | busybox sed 's!./!!'); do
    
  #if [ ! -z "$(busybox hexdump -C -n 20 "$a" 2> /dev/null | busybox grep -o "41 56 42 30")" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox grep '3a ff 26 ed')" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox awk '/00000430/ { print $10$11 }' | busybox grep "53ef")" -o ! -z "$(busybox hexdump -C -n 2000 "$a" 2> /dev/null | busybox grep -o '41 4e 44 52 4f 49 44 21')" -o ! -z "$(busybox hexdump -C -n 2000 "$a" | busybox grep -o 'e2 e1 f5 e0')" -o ! -z "$(busybox hexdump -C -n 2000 "$a" | busybox grep -o '10 20 f5 f2 ')" ]; then
       echo "$a"
     #fi
     done | busybox sort -f)

 set -- $v

 if [ ! -z "$v" ]; then
 clear
 echo
 echo ".....Select file:"
 echo
 select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
          clear
         . /data/local/binary/extract_key "$file"

         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         extract_key
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         extract_key
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."В папке \"/$nd\" No Fileов \"*.img\""
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
extract_key
return
fi
return
}
 extract_key
   break ;;
      4 ) clear
         gen_key()
{
v=$(echo "RSA2048" "RSA4096" "RSA8192")

set -- $v
echo
echo ".....Select an algorithm to generate a key:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 rs="$(echo "$file" | busybox sed 's!RSA!!')"
 out_gen_key=/data/local/UnpackerSystem/gen_keys
 mkdir "$out_gen_key" 2> /dev/null
 time="$(busybox date +%H_%M_%S)"
         clear
 echo
 echo ".....Generating keys ${file}_${time}_private.pem и ${file}_${time}_pubkey.pem..."

         openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:"$rs" -outform PEM -out "$out_gen_key"/"$file"_${time}_private.pem &> /dev/null
if [ $(echo $?) -eq 0 ]; then

echo
echo ".....Successfully created "$file"_${time}_private.pem "
echo ".....Saved: "$out_gen_key"/"$file"_${time}_private.pem"

avbtool extract_public_key --key "$out_gen_key"/"$file"_${time}_private.pem --output "$out_gen_key"/"$file"_${time}_pubkey.pem
if [ $(echo $?) -eq 0 ]; then
sleep 1
echo
echo ".....Successfully created "$file"_${time}_pubkey.pem"
echo ".....Saved: "$out_gen_key"/"$file"_${time}_pubkey.pem"
echo
fi
fi

         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         gen_key
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         gen_key
         return
         break;;
  esac
 done
return
}
 gen_key
   break ;;
      5 ) clear
          . /data/local/binary/rem_key
          break ;;
      6 ) clear
          . image_sign
          #main_menu
          break ;;
      7 ) clear
               main_menu
               break ;;
      8 ) clear
          break ;;
      
         * ) clear
            echo
            echo "      Enter the numbers corresponding to this Menu."
              read_avb
              return
              break ;;
    esac
done
return
}
read_avb
  break ;;
          
          2 ) clear


sin_img()
{
              echo
              echo "..Go to the folder where File \".sin\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
v=$(busybox find . -maxdepth 1 -name '*.sin' 2> /dev/null | busybox sed 's!./!!')

konv()
{
         echo
         echo ".....Convert..."
         echo
         if [ ! -z "$(echo "$file" | busybox grep ".sin$")" ]; then
        
        name_sin="$(busybox basename ${file%%.*})"
   
        sony_dump "$PWD" "$file"
        if [ $(echo $?) -eq 0 ]; then
      num="$(busybox find -maxdepth 1 | busybox grep -Ev ".sin$|.crt$|.img$|.log$|.txt$" | busybox grep "$name_sin")"
       busybox mv -f "$num" "$name_sin"_sin.img && file=/"$nd"/"$name_sin"_sin.img
          echo
         echo ".....Successfully completed!"
         echo ".....Received File $file"
         echo
         else
          echo
         echo ".....Error. Error during conversion!"
         echo
         fi
         fi
return
}

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         konv
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         sin_img
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         sin_img
         return
         break;;
  esac
 done
 else
 echo
 echo ....."В папке \"/$nd\" No Fileов \".sin\"."
 echo
 main_menu
return
 fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
sin_img
return
fi
return
}
sin_img
  break ;;
        
          3 ) clear
             echo
            echo "      Menu: Convert .lz4|.zst|.xz|.lzma"
            echo
select img in "Extracting from .lz4|.zst|.xz|.lzma" "Compressing .img to .lz4|.zst|.xz|.lzma" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
             
             decomp_lz4()
{
              echo
              echo "..Go to the folder where File .lz4|.zst||.xz|.lzma is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }'| busybox sed 's!^/!!')

#v=$(busybox find . -maxdepth 1 -name '*.lz4' 2> /dev/null | busybox sed 's!./!!')

v=$(for fol in $(busybox find . -maxdepth 1 -name "*.lz4" -o -name "*.lzma" -o -name "*.zst" -o -name "*.xz" -type f); do
mag="$(/data/local/binary/file -m /data/local/binary/magic "$fol" 2> /dev/null | busybox awk '{ print $2 }')"
if [ "$mag" == "lzma" -o  "$mag" == "lz4" -o "$mag" == "xz" -o ! -z "$(busybox hexdump -C -n 2000 "$fol" 2> /dev/null | busybox grep -o "28 b5 2f fd" 2> /dev/null)" ]; then
echo "$fol"
 fi
done | busybox sort -f)

konv()
{       
  o="$(busybox basename $file)"
  o_name=${o%.*}
  file_or="$(echo "$file" | busybox sed 's!^./!!')"
  file_print="$(echo "$o_name" | busybox sed 's!^./!!')"
        echo
        echo ".....Extract from /$nd/$file_or..."
        echo
         #lz4 -df --no-sparse "$file"
         
    if [ -z "$(getprop ro.product.cpu.abilist64)" ]; then
        zstd32 -df "$file"
    else
        zstd64 -df "$file"
   fi
  
         if [ "$?" -eq "0" ]; then
         echo
         echo ".....Successfully completed!"
         echo ".....Received File: /$nd/${file_print}"
         echo
         return
         else
         echo
         echo ".....Error while extracting!"
         echo
         return
         fi
return
}

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file to convert:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         konv
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         decomp_lz4
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         decomp_lz4
         return
         break;;
  esac
 done
 else
 echo
 echo ....."В папке \"/$nd\" No Fileов для извлечения."
 echo
 main_menu
return
 fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
decomp_lz4
return
fi
return
}
decomp_lz4
  break ;;
           2) clear
             
             comp_lz4()
{
              echo
              echo "..Go to the folder where File \".img\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
v=$(busybox find . -maxdepth 1 -name '*.img' 2> /dev/null | busybox sed 's!./!!')

konv()
{        
         clear
  if [ "$part_name" == "zst" ]; then
  part_name="zstd"
  part_print="zst"
  else
  part_name="$part_name"
  part_print="$part_name"
  fi
         echo
         echo ".....Compression in $part_print..."
         echo
   if [ -z "$(getprop ro.product.cpu.abilist64)" ]; then
   zstd32 --adapt --format="$part_name" -f "$file_conv"
   else
   zstd64 --adapt --format="$part_name" -f "$file_conv"
   fi
     if [ "$?" -eq "0" ]; then
         echo
         echo ".....Successfully completed!"
         echo ".....Received File /$nd/${file_conv}.${part_print}"
         echo
         return
         else
         echo
         echo ".....Compression in!"
         echo
         return
         fi
return
}

 part_num()
{
 clear
v=$(echo "lz4" "zst" "xz" lzma)

set -- $v
echo
echo ".....Select compression format:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then

 part_name="$file"
 
 
 konv
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
        clear
        #main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         part_num
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         part_num
         return
         break;;
  esac
 done
return
}



set -- $v

if [ ! -z "$v" ]; then
#if [ "$#" -le "10" ]; then
echo
echo ".....Select file to convert:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         file_conv="$file"
         part_num
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         comp_lz4
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         comp_lz4
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."There are no \".img\" Files in the \"/$nd\" folder to compress."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
comp_lz4
return
fi
return
}
comp_lz4
  break ;;
           3) clear
              main_menu
              break ;;
           4) clear
              break;;
   esac
    done
      break ;;
         4 ) clear

           resize_img()
{
 blockcount=$(tune2fs -l ./$obraz | busybox awk '/Block count/ { print $3 }')
size=$(stat -c %s ./$obraz)
size_obraz=$(busybox expr $blockcount \* 4096)
if [ -f ./$obraz ]; then
busybox test "$size" -lt "$size_obraz"
if [ "$?" -eq "0" ]; then
busybox truncate -s $size_obraz ./$obraz
echo " .....Received image \"$obraz\" with size: $size_obraz byte."
echo ".....Saved в /data/local/UnpackerQfil"
else
echo " .....Received image \"$obraz\" with size: $size byte."
echo ".....Saved в /data/local/UnpackerQfil"
fi
fi
}

             qfil_img()
{

 free_space="$(busybox df -h /data/local/UnpackerQfil | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "     Place in the folder: /data/local/UnpackerQfil all Files \"super_xx|system_xx|vendor_xx|userdata_xx\" and all Files \".xml\", starting with \"rawprogram*\", or Files \"super|system|vendor.img_sparsechunk.*\"."
 echo
 echo "...В /data/local/UnpackerQfil freely: $free_space"
 echo
 select img in "Glue together" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
             cd /data/local/UnpackerQfil
 >qfil.log
 #name_qfil="system_|vendor_|userdata_|.xml"
 if [ ! -z "$(busybox ls | busybox grep -E "super.img.*[0-9]|system_|vendor_|userdata_|.xml|chunk")" ]; then

 if [ ! -z "$(busybox ls *chunk* 2> /dev/null)" ]; then

 echo
 echo ".....Files Found \"*sparsechunk*\""
 echo
 for name in "super" "system" "vendor" "product"; do
 #name1=$(busybox find . -name "${name}*sparsechunk.*[0-9]" -a ! -name "${name}*sparsechunk.*[0-9][0-9]" | sort -n)
 name1=$(find . -maxdepth 1 -name "${name}*chunk*" | sort -n | busybox grep -v "[0-9][0-9]")
 #name2=$(busybox find . -name "${name}*sparsechunk.*[0-9][0-9]" | sort -n)
 name2=$(find . -maxdepth 1 -name "${name}*chunk*" | sort -n | busybox grep "[0-9][0-9]")
 if [ ! -z "${name1}"  ]; then
 mkdir ./output 2> /dev/null
 
 #name_out=$(echo $name1 | busybox sed 's!./!!' | busybox awk -F"img" '{ print $1 }')
 echo ".....Склейка ${name}_chunk.raw.img..."
 simg2img ${name1} ${name2} ./output/${name}_chunk.raw.img
 if [ "$?" -eq "0" ]; then
 #echo
 echo ".....Successfully created File ${name}_chunk.raw.img"
 echo ".....Saved в /data/local/UnpackerQfil/output"
 echo
 else
 echo
 echo ".....Error while gluing ${name}_chunk.raw.img!"
 echo
 fi
 fi
 done

 elif [ ! -z "$(busybox ls super.img*[0-9] 2> /dev/null)" ]; then

 echo
 echo ".....Files Found \"*sparsechunk*\""
 echo
 for name in "super"; do

 name1=$(find . -maxdepth 1 -name "super.img*[0-9]" | sort -n | busybox grep -v "[0-9][0-9]")

 name2=$(find . -maxdepth 1 -name "super.img*[0-9]" | sort -n | busybox grep "[0-9][0-9]")
 if [ ! -z "${name1}"  ]; then
 mkdir ./output 2> /dev/null
 
 echo ".....Gluing ${name}_chunk.raw.img..."
 simg2img ${name1} ${name2} ./output/${name}_chunk.raw.img
 if [ "$?" -eq "0" ]; then
 #echo
 echo ".....Successfully created File ${name}_chunk.raw.img"
 echo ".....Saved в /data/local/UnpackerQfil/output"
 echo
 else
 echo
 echo ".....Error while gluing ${name}_chunk.raw.img!"
 echo
 fi
 fi
 done
 fi

#new str

 for name in "super" "system" "vendor" "userdata"; do
 obraz=$name.raw.img
 #rab_file=$(busybox find -name "rawprogram*" -exec busybox grep -rl "$name" {} \; | busybox sed 's!./!!' | busybox tail -1)
 
 busybox find -name "rawprogram*.xml" -exec busybox grep -rl "$name" {} \; | busybox sed 's!./!!' | while read a; do
 if [ "$(busybox cat "$a" | busybox grep "$name" | busybox wc -l)" -ge "3" ]; then
 echo "$a" > rab_file.txt
 fi
 done
 rab_file="$(busybox cat rab_file.txt 2> /dev/null)"
 

 

#check_name="$(busybox cat $rab_file | busybox grep -o "${name}.*" | busybox head -1 | busybox awk '{print $1}' | busybox sed 's!"!!g')"

 #check_name="$(busybox cat $rab_file | busybox awk -v var="$name" -F"filename=" '$2 ~ var { print $2}' | busybox cut -d" " -f1 | busybox sed '1!d; s!"!!g')"

 if [ ! -z $rab_file ]; then
 check_name="$(busybox cat $rab_file | busybox awk -v var="$name" -F"filename=" '$2 ~ var { print $2}' | busybox cut -d" " -f1 | busybox sed '1!d; s!"!!g')"
 if [ -f ./$check_name ]; then
 echo
 echo ".....Found File ${rab_file}"
 echo ".....Gluing $image using Fileа $rab_file..."
 python31 /data/local/binary/bin_system/qfil1.py /data/local/UnpackerQfil/"$rab_file" "$name"
  if [ "$?" -eq "0" ]; then
obraz_real="/data/local/UnpackerQfil/$obraz"
 opla_r=$(busybox hexdump -C -n 20000 "$obraz_real" | busybox grep -o "30 50 4c 41")
 sparse_super_r=$(busybox hexdump -C -n 20000 "$obraz_real" | busybox grep -o "3a ff 26 ed")
 size_obraz_r="$(lpdump --slot=0 "$obraz_real" | busybox awk '/Size: / { print $2 }')"
 if [ ! -z "$opla_r" -a -z "$sparse_super_r" ]; then
 busybox truncate -s "$size_obraz_r" "$obraz_real"
 if [ "$?" -eq "0" ]; then
 echo
 echo " .....Received image \"$obraz\" with size: $size_obraz_r byte."
 echo ".....Saved в /data/local/UnpackerQfil"
 else
 echo
 echo "Error adjusting size of $obraz"
 echo
fi
 else
 resize_img
 fi
             else
             echo ".....An error occurred"
             echo
             fi
            else
            echo
            echo ".....No Fileа \"$check_name\" в /data/local/UnpackerQfil" >> qfil.log
             fi
             else
            #clear
            echo
            echo ".....No necessary Fileа .xml в /data/local/UnpackerQfil" >> qfil.log
             fi
  done
             else
             echo
             echo ".....No Files to glue in /data/local/UnpackerQfil"
             fi
             main_menu
             break ;;
         2 ) clear
              main_menu
               break ;;
         3 ) clear
               break ;;
         *) clear
            echo
            echo "      Enter the numbers corresponding to this Menu."
              qfil_img
              break ;;
    esac
done
return
}
qfil_img
break ;;
         5 ) clear
         split_super()
{

 v=$(for a in $(busybox find . -maxdepth 1 -name '*.img' -type f | busybox sed 's!./!!'); do
    
  if [ ! -z "$(busybox hexdump -C -n 20000 "$a" | busybox grep -o "30 50 4c 41")" -o ! -z "$(busybox hexdump -C -n 2000 "$a" | grep -o "3a ff 26 ed")" ]; then
 echo "$a"
     fi
     done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear

if [ ! -z "$(getprop ro.product.cpu.abilist64)" ]; then
if [ ! -z "$(busybox hexdump -C -n 2000 "$file" | grep -o "3a ff 26 ed")" ]; then

 echo
 echo "......Convert $file -> super.raw.img..."
 echo
 simg2img "$file" /data/local/UnpackerQfil/super.raw.img
  if [ "$?" -eq "0" ]; then
 file="super.raw.img"
. /data/local/binary/ai
 else
 echo
 echo ".....Compression in $file"
 echo
 fi
 else
 . /data/local/binary/ai
 fi
else
echo
echo ".....Splitting super.img is not supported on 32-bit firmware!"
echo
fi
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         split_super
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         split_super
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."In folder \"/data/local/Unpacker Qfil\" No suitable super.img for splitting."
 echo
 main_menu
return
fi
return
}

split_selekt()
{
echo
echo "...Place the super.img(raw) that needs to be split into the folder: /data/local/UnpackerQfil"

 free_space="$(busybox df -h /data/local/UnpackerQfil | busybox tail -1 |  busybox awk '{ print $(NF-2) }')"
 echo
 echo "...В /data/local/UnpackerQfil freely: $free_space"
 echo
 select img in "Divide super.img" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
             cd /data/local/UnpackerQfil
             split_super
             #main_menu
             break ;;
         2 ) clear
              main_menu
               break ;;
         3 ) clear
               break ;;
         *) clear
            echo
            echo "      Enter the numbers corresponding to this Menu."
              split_selekt
              break ;;
    esac
done
return
}
split_selekt
  break ;;
         6 ) clear
             payload()
{
              echo
              echo "         Extract from payload.bin     "
              echo
              echo "..Go to the folder where File \"payload.bin\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')

 v=$(for a in $(busybox find . -maxdepth 1 -name '*.bin' -type f | busybox sed 's!./!!'); do
    
  if [ ! -z "$(busybox hexdump -C -n 20 "$a" | busybox grep -o "43 72 41 55")" ]; then
       echo "$a"
     fi
     done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
 echo
 echo ".....Cleaning /data/local/UnpackerPayload..."
 #echo
  busybox find /data/local/UnpackerPayload/* -maxdepth 1 ! -name "*.bin" -type f -exec busybox rm -f {} \; 2> /dev/null
              echo
              echo ".....Extract from /$nd/$file..."
              echo

if [ -z "$(getprop ro.product.cpu.abilist64)" ]; then
        otadump="otadump7x32"
    else
        otadump="otadump7x64"
fi

 "$otadump" -c 8 -o /data/local/UnpackerPayload "$file"
 if [ $(echo $?) -eq 0 ]; then
 clear
 echo
 echo ".....images extracted successfully!"
 echo ".....Saved в /data/local/UnpackerPayload!"
 echo
 else
 echo
 echo ".....Error while extracting!"
 echo
 echo ".....We use the old extraction method"
 echo ".....Extract from /$nd/$file..."
 echo
 
 busybox find /data/local/UnpackerPayload/* -maxdepth 1 ! -name "*.bin" -type f -exec busybox rm -f {} \; 2> /dev/null
 payload-dumper -c 8 -o /data/local/UnpackerPayload "$file"
 if [ $(echo $?) -eq 0 ]; then
 clear
 echo
 echo ".....images extracted successfully!"
 echo ".....Saved в /data/local/UnpackerPayload!"
 echo
 else
 echo
 echo ".....Error while extracting!"
 echo
 fi
 fi
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         payload
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         payload
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."In the folder \"/$nd\" No Files \".bin\" to extract images."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
payload
return
fi
return
}
 payload
    break ;;

         7 ) clear
             update_app()
{
              echo
              echo "         Extract from UPDATE.APP     "
              echo
              echo "..Go to the folder where File \"*.app\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
#dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
#v=$(busybox find . -maxdepth 1 -iname '*.app' 2> /dev/null | busybox sed 's!./!!')

 v=$(for a in $(busybox find . -maxdepth 1 -iname '*.app' -type f | busybox sed 's!./!!'); do
    
  if [ ! -z "$(busybox hexdump -C -n 100 "$a" | busybox grep -o "55 aa 5a a5")" ]; then
       echo "$a"
     fi
     done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
              echo
              echo ".....Extract from /$nd/$file..."
              echo
 python31 /data/local/binary/bin_system/splitapp_v2.py -f "$file" -o /data/local/UnpackerUpdateApp

   if [ $(echo $?) -eq 0 ]; then
 cd /data/local/UnpackerUpdateApp
 napp=$(busybox find -name "super_[0-9].img" -type f | sort -n)
 if [ ! -z "$napp" ]; then
 echo
 echo ".....Gluing together the broken pieces super.img..."
 simg2img ${napp} super.raw.img
 if [ $(echo $?) -eq 0 ]; then
echo
 echo ".....images extracted successfully!"
 echo ".....Saved в /data/local/UnpackerUpdateApp!"
 echo
 else
 echo
 echo ".....Error while gluing!"
 echo
fi
 else
 echo
 echo ".....images extracted successfully!"
 echo ".....Saved в /data/local/UnpackerUpdateApp!"
 echo
 fi
 else
 echo
 echo ".....Error while extracting!"
 echo
 fi
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         update_app
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         update_app
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."В папке \"/$nd\" No Fileов \".app\" для извлечения imageов."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
update_app
return
fi
return
}
 update_app
    break ;;
         8 ) clear
           . /data/local/binary/mmm
             return
             main_menu
             return
             break ;;
         9 ) clear
             my_ozip()
{
             cd
             echo 
             echo "...Go to the folder where Files: \".ozip\" are located, for example: cd /sdcard"
 read b && $b
 if [ $(echo $?) -eq 0 ]; then
 nd=$(echo $b | busybox awk '{ print $2 }')
  clear
  ss_ozip()
{
 
 v=$(for a in $(busybox find . -maxdepth 1 -name '*.ozip' -type f | busybox sed 's!./!!'); do
       echo "$a"
     done | busybox sort -f)

 set -- $v
 if [ ! -z "$v" ]; then
 echo
 echo ".....Select file:"
 echo
 select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
        echo
        python31 /data/local/binary/bin_system/ozipdecrypt.py "$file"
   if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Successfully completed!"
 echo
 else
 echo
 echo ".....error: An error occurred!"
 echo
 fi
         main_menu
         return
         break
         elif [ "$REPLY" -eq "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         ss_ozip
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         ss_ozip
         return
         break;;
  esac
 done
 else
 echo
 echo ".....In the folder \"$nd\" No Fileов \".ozip\"."
 echo
 main_menu
return
 fi
 return
}
 ss_ozip
 else
 echo
 echo ".....error: Error moving to directory!"
 echo
 echo "Please enter the directory correctly!"
 echo
 my_ozip
 return
 fi
 return
}
 my_ozip
    break ;;
         10 ) clear
  
             comp_md5()
{
              echo
              echo "         Creation tar.md5     "
              echo
              echo "..Go to the folder where File \"*.img\" or \"*.zip\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
dir_dat=/data/local/binary
nd=$(echo $b | busybox awk '{ print $2 }')
v=$(busybox find . -maxdepth 1 -name '*.img' -o -name '*.lz4' 2> /dev/null | busybox sed 's!./!!')

set -- $v

if [ ! -z "$v" ]; then
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
 file_tar="$file".tar
 file_name="$(echo "$file" | busybox sed 's!\.[^.]*$!!')"
 busybox tar -cf "$file".tar "$file" && busybox md5sum "$file_tar" >> "$file_tar" && busybox mv "$file_tar" "$file_tar".md5
 if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Successfully created File: "$file_tar".md5"
 echo
 else
 echo
 echo ".....Error while creating "$file_tar".md5!"
 echo
 fi
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         comp_md5
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         comp_md5
         return
         break ;;
  esac
 done
 else
 echo
 echo ....."In the folder \"$nd\" No Files \".img\" for conversion."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
comp_md5
return
fi
return
}
 comp_md5
    break ;;
         11 ) clear
 
              rokchip_extract()
{
              echo
              echo "         Unpacking firmware .img     "
              
  rok_dir="/data/local/UnpackerSystem"

              echo
              echo "..Go to the folder where the firmware File \".img\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
echo
echo ".....Search files..."

 v=$(for a in $(busybox find . -maxdepth 1 -name '*.img' -type f | busybox sed 's!./!!'); do
    
  
  if [ "$(busybox hexdump -C -n 300 "$a" | busybox grep -Eo "52 4b 46 57 66|52 4b 41 46|49 4d 41 47 45 57 54 59|56 19 b5 27")" ]; then
     echo "$a"
     fi
     done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
clear
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
  name_rok="$(echo "$file" | busybox sed 's!.img$!!')"
  
  if [ -d "$rok_dir"/"$name_rok" -a "$rok_dir"/"$name_rok" != "$rok_dir"/ ]; then
          echo
          echo ".....Deleting the old folder: "$rok_dir"/"$name_rok""
          busybox rm -rf "$rok_dir"/"$name_rok"
          
  fi


 if [ "$(busybox hexdump -C -n 20 /"$nd"/"$file" | busybox grep -Eo "52 4b 46 57 66|52 4b 41 46")" ]; then

              echo
              echo ".....Detected Magic Rockchip..."
              echo
              echo ".....Extract from /$nd/$file..."
              echo
    if [ ! -z "$(busybox hexdump -C -n 20 /"$nd"/"$file" | busybox grep -o "52 4b 46 57 66")" ]; then
 busybox mkdir "$rok_dir"/"$name_rok" 2> /dev/null
echo "rkfwf" > "$rok_dir"/"$name_rok"/conf
 
 busybox dd if="$file" of="$rok_dir"/"$name_rok"/tmpt bs=3000000 count=1 &>/dev/null
 VER="$(busybox strings "$rok_dir"/"$name_rok"/tmpt | busybox awk -F"\:"  '/FIRMWARE_VER/ { print $2 }' | busybox awk -F"\." '{!$3} {$(NF+1)=0;} { print $1"."$2"."$3 }')"
 echo "rom_version: "$VER""
 busybox rm -f "$rok_dir"/"$name_rok"/tmpt
 img_unpack "$file" "$rok_dir"/"$name_rok"
 if busybox test -s "$rok_dir"/"$name_rok"/update.img; then
 cd "$rok_dir"/"$name_rok"
 afptool -unpack update.img .
 if busybox test -s "$(busybox find "$rok_dir"/"$name_rok" -name "parameter*" | busybox head -1)"; then
 echo
 echo ".....images extracted successfully!"
 echo ".....Saved в "$rok_dir"/"$name_rok""
 echo
 else
 echo
 echo ".....Error! Error while extracting!"
 echo
 fi
 #fi
 else
 echo
 echo ".....Error! Error while extracting, No update.img!"
 echo
 fi

 elif [ ! -z "$(busybox hexdump -C -n 20 /"$nd"/"$file" | busybox grep -o "52 4b 41 46")" ]; then
 busybox mkdir "$rok_dir"/"$name_rok" 2> /dev/null
echo "rkaf" > "$rok_dir"/"$name_rok"/conf
 

 busybox cp -f /"$nd"/"$file" "$rok_dir"/"$name_rok"/update.img
 cd "$rok_dir"/"$name_rok"
 afptool -unpack update.img .
 if busybox test -s "$(busybox find "$rok_dir"/"$name_rok" -name "parameter*" | busybox head -1)"; then
 echo
 echo ".....images extracted successfully!"
 echo ".....Saved в "$rok_dir"/"$name_rok""
 echo
 else
 echo
 echo ".....Error! Error while extracting!"
 echo
 fi
 fi



       busybox rm -f update.img
   elif [ "$(busybox hexdump -C -n 3000 /"$nd"/"$file" | busybox grep -o "49 4d 41 47 45 57 54 59")" ]; then
              clear
              echo
              echo ".....Detected Magic Alwinner..."
              echo
              echo ".....Extract from /$nd/$file..."
              echo
 busybox cp -f /"$nd"/"$file" "$rok_dir"/"$file"
 cd "$rok_dir"
 awimage "$file"
 if [ $(echo $?) -eq 0 ]; then
 busybox mv -f /"$rok_dir"/"$name_rok".img.dump /"$rok_dir"/"$name_rok"
 echo
 echo ".....images extracted successfully!"
 echo ".....Saved в "$rok_dir"/"$name_rok""
 echo
 busybox rm -f "$file"
 else
 echo
 echo ".....Error! Error while extracting!"
 echo
 fi

 elif [ "$(busybox hexdump -C -n 3000 /"$nd"/"$file" | busybox grep -o "56 19 b5 27")" ]; then
              clear
              echo
              echo ".....Detected Magic Amlogic..."
              echo
              echo ".....Extract from /$nd/$file..."
              echo
 busybox mkdir "$rok_dir"/"$name_rok" 2> /dev/null
 ampack unpack /"$nd"/"$file" "$rok_dir"/"$name_rok"
 if [ $(echo $?) -eq 0 ]; then
 echo "amlogic" > "$rok_dir"/"$name_rok"/type_img.txt
 echo
 echo ".....images extracted successfully!"
 echo ".....Saved в "$rok_dir"/"$name_rok""
 echo
 else
 echo
 echo ".....Error! Error while extracting!"
 echo
 fi
   fi

         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         rokchip_extract
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         rokchip_extract
         return
         break ;;
  esac
 done
 else
 clear
 echo
 echo ....."In the folder \"/$nd\" No firmware \".img\" to extract images."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
rokchip_extract
return
fi
return
}


rokchip_pack()
{

 rok_dir="/data/local/UnpackerSystem"
 cd "$rok_dir"
 b=$(for a in $(busybox find -maxdepth 1 ! -name "." -type d | busybox sed 's!./!!'); do
 if busybox test -s "$a"/platform.conf; then
 echo "$a"
 fi
 done | busybox sort -f)

set -- $b

if [ ! -z "$b" ]; then
echo
echo ".....Select a folder for assembly:"
echo
select menu in $b "Exit to the main Menu" "Completion of work"; do
case $REPLY in
                 [1-9]*) i="$#"
                      j="$#"
                      let i=i+1
                      let j=j+2
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
       if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
         clear
         name_rok=$file
       if busybox test -s "$name_rok"/Image/parameter*; then   
         busybox cp -f "$name_rok"/Image/parameter.txt "$name_rok"/parameter
 load="$(busybox grep "bootloader" "$name_rok"/package-file | busybox awk '{ print $2}')"
 for r in "29" "30" "31" "32" "33"; do
rk_tmp="$(busybox cat "$name_rok"/parameter | busybox awk '/MACHINE:/ { print $2 }' | busybox grep -Eo '[0-9]{1,2}' | busybox head -1)"

 if [ "$rk_tmp" == "$r" ]; then
rk_v="-rk$rk_tmp "
fi
done
 if [ ! -z "$load" ]; then
 clear
 echo
 echo ".....Assembly firmware .img..."
 echo
 busybox sleep 2

afptool -pack "$name_rok" update.new.img
 if [ $(echo $?) -eq 0 ]; then
 echo "img_maker "$rk_v""$name_rok"/"$load" update.new.img "$outdir"/"$name_rok"_new.img" > pack.sh
 chmod 755 ./pack.sh && ./pack.sh
 if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Successfully created "$outdir"/"$name_rok"_new.img"
 echo
 else
 echo
 echo ".....error during assembly general imageа!"
 echo
 fi
 else
 echo
 echo ".....error during assembly primary imageа!"
 echo
 fi
 else
 echo ".....Configuration error!"
 fi
      busybox rm -f update.new.img pack.sh
      
      elif busybox test ! -z "$(busybox cat "$name_rok"/type_img.txt | busybox grep -o "amlogic")"; then
      echo
      echo ".....Assembly firmware .img..."
      echo
      busybox sleep 2
      ampack pack --verify "$rok_dir"/"$name_rok" "$rok_dir"/"$name_rok".new.img 
       if [ $(echo $?) -eq 0 ]; then
 echo
 echo ".....Successfully created "$rok_dir"/"$name_rok"_new.img"
 echo
 main_menu
 return
 else
 echo
 echo ".....error during assembly general imageа!"
 echo
 main_menu
 return
 fi
      fi
         main_menu
         return
         break
       elif [ "$REPLY" -eq "$i" ]; then
         clear
        main_menu
        return
        break
       elif [ "$REPLY" -eq "$j" ]; then
         clear
        return
        break
       else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         rokchip_pack
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
         rokchip_pack
         return
         break;;
  esac
  done
 else
 echo
 echo ....."В \"$PWD\" there are no folders for assembly."
 echo
 main_menu
 return
 fi
return
}


  menu_rok()
  {
 if [ ! -z "$(getprop ro.product.cpu.abilist64)" ]; then
              echo
              echo "         Unpacking firmware .img     "
              echo
 select img in "Unpack firmware .img" "Collect firmware .img(Only Amlogic)" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
                1 ) clear
                    rokchip_extract
                    break ;;
                2 ) clear
                    rokchip_pack
                    break;;
                 3 ) clear
                    main_menu
                    break ;;
                 4 ) clear
                     break ;;
                * ) clear
            echo
            echo "      Enter the numbers corresponding to Menu."
            echo
            menu_rok
              break ;;
esac
done
 else
 echo
 echo ".....The operation of the Menu item: \"Unpacking firmware .img\" is not supported on 32-bit firmware!"
  echo
    main_menu
 fi
return
 }
 menu_rok
  break
   main_menu
    break ;;
    
         12 ) clear

       aa()
{
 #m_name="$(busybox basename "$file" | busybox sed 's!.ofp$!!')"
cd /data/local/UnpackerSystem
if busybox test -s "$m_name"/super_map.csv; then
v="$(busybox cat "$m_name"/super_map.csv | busybox awk -F"," '! /nv_text/ { print $1"-"$2 }')"
 elif busybox test -s "$m_name"/ProFile.xml; then
 v="$(busybox cat "$m_name"/ProFile.xml | busybox awk -F'"' '/<nv id/ { print $2"-"$4 }')"
 fi
set -- $v
echo
echo ".....Select region for gluing super.raw.img:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                  [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 if busybox test -s "$m_name"/super_map.csv; then
         ddd="$(echo "$file" | busybox sed 's!-!,!')"
         f_ext="$(busybox cat "$m_name"/super_map.csv | busybox grep "$ddd" | busybox awk -v a="$m_name" -F"," '! /nv_text/ { print a"/"$3" "a"/"$4" "a"/"$5 }')"
         
   elif busybox test -s "$m_name"/ProFile.xml; then
 f_ext="$(busybox cat "$m_name"/ProFile.xml | busybox awk -F'"' '/<nv id/ { print $2"-"$4" "$6" "$8" "$10 }' | busybox grep "$file" | busybox awk -v a="$m_name" '{ print a"/"$2" "a"/"$3" "a"/"$4 }')"
 fi
         f_out="super_"${file}".raw.img"
 echo "simg2img "$f_ext" "$m_name"/"$f_out"" > pack.sh

 clear
 echo
 echo ".....Gluing $f_out, Waiting..."
 chmod 755 ./pack.sh && ./pack.sh
 if [ $(echo $?) -eq 0 ]; then
   echo
   echo ".....Successfully completed!"
   echo
  return
  else
   echo
   echo ".....Error while gluing super.raw.img!"
   echo
   return
  fi
         return
         break
         elif [ "$REPLY" -eq "$i" ]; then
         clear
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         aa
         return
         break
         fi
         break;;
      *) clear
         echo
            echo "      Enter the numbers corresponding to Menu."
        aa
         return
         break;;
  esac
 done
return
}

              ofp()
{

 m_name="$(busybox basename "$file" | busybox sed -e 's!.ofp$!!; s!.ops$!!')"

 cd /data/local/UnpackerSystem
 mkdir "$m_name" 2> /dev/null
 >super_simg
 echo 
 echo ".....Extracting images from "$file""
 echo ".....We are waiting..."
 echo
 #python39 /data/local/binary/bin_oppo_decrypt/ofp_mtk_decrypt.py "$file" "$m_name" 1> log.txt
 #python39 /data/local/binary/bin_oppo_decrypt/ofp_qc_decrypt.py "$file" /"$ofp_dir"/"$m_name" 1>> log.txt
 #busybox cp -f log.txt "$m_name"/log.txt
 
 
 python31 /data/local/binary/OppoDecrypt-main -c mtk "$file" /"$ofp_dir"/"$m_name" 1> log.txt
 if [ -z "$(busybox cat log.txt | busybox tail -3 | busybox grep "ERROR")" -a -s log.txt ]; then
   echo
   echo ".....images extracted successfully в /data/local/UnpackerSystem/$m_name"
   echo
   ofp_exit="10"
else
python31 /data/local//binary/OppoDecrypt-main -c qualcomm "$file" /"$ofp_dir"/"$m_name" 1> log.txt
if [ -z "$(busybox cat log.txt | busybox tail -3 | busybox grep "ERROR")" -a -s log.txt ]; then
   echo
   echo ".....images extracted successfully в /data/local/UnpackerSystem/$m_name"
   echo
   ofp_exit="10"
else
echo
 echo ".....Error while extracting!"
echo
fi
fi



 busybox cp -f log.txt "$m_name"/log.txt

  #if [ ! -z "$(busybox cat log.txt | busybox grep -E "Files successfully|Done. Extracted")" ]; then
   #echo
   #echo ".....images extracted successfully в /data/local/UnpackerSystem/$m_name"
   #echo
   #ofp_exit="10"
  #else
   #echo
   #echo ".....Error while extracting!"
   #echo
  #fi

 check_sup="$(busybox cat log.txt | busybox awk '/super.[0-9]/ { print $5 }' | busybox sed 's!"!!g')"
 if [ "$ofp_exit" == "10" -a ! -z "$check_sup" ]; then
 #>super_simg
 echo
 echo ".....Found super.img, broken into pieces!"
 if [ "$check_pack" == "0" ]; then
 #i=0
 echo "$check_sup" | while read a; do
 #let i=i+1
 #f="$m_name/super."$i".img"
 f="$m_name/${a}"
 #echo -ne "$f " >> super_simg
 if [ ! -z "$(echo "$a" | busybox grep ".img")" ]; then
 echo -ne "$f " >> super_simg
 #busybox mv "$m_name"/"$a" "$f"
 else
 #busybox mv "$m_name"/"$a".img "$f"
 echo -ne "${f}.img " >> super_simg
 fi
 done

 echo 
 echo ".....Gluing super.raw.img! We are waiting..."
 
 echo "simg2img "$(busybox cat super_simg)"$m_name/super.raw.img" > super.sh
 if [ ! -z "$(busybox cat super.sh | busybox awk '/super/ { print $2 }')" ]; then
 chmod 755 super.sh && ./super.sh

 if [ $(echo $?) -eq 0 ]; then
   echo
   echo ".....Successfully completed!"
   echo
  else
   echo
   echo ".....Error while gluing super.raw.img!"
   echo
  fi
 fi
 elif [ "$check_pack" == "1" -a -s  "$m_name"/super_map.csv -o "$check_pack" == "1" -a -s "$m_name"/ProFile.xml ]; then
 aa
 else
 echo
 echo ".....No File for gluing by region!"
 echo
  fi
  fi
 busybox rm -f super_simg super.sh log.txt pack.sh
 main_menu
  return
}

ofp_extract()
{
              echo
              echo "         Unpacking firmware .ofp|.ops     "
              
  ofp_dir="/data/local/UnpackerSystem"

              echo
              echo "..Go to the folder where File firmware \".ofp|.ops\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
echo
echo ".....Search files..."

 v=$(for a in $(busybox find . -maxdepth 1 -name '*.ofp' -o -name '*.ops' -type f | busybox sed 's!./!!'); do
     echo "$a"
     done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
clear
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu"; do
case $REPLY in
                 [1-9]*) i="$#"
                      let i=i+1
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
  name_ofp="$(echo "$file" | busybox sed 's!.ofp$!!')"
file=/"$nd"/"$file"
  
  if [ -d "$ofp_dir"/"$name_ofp" -a "$ofp_dir"/"$name_ofp" != "$ofp_dir"/ ]; then
          echo
          echo ".....Deleting the old folder: "$ofp_dir"/"$name_ofp""
          busybox rm -rf "$ofp_dir"/"$name_ofp"
          fi
         ofp
         return
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         ofp_extract
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         ofp_extract
         return
         break ;;
  esac
 done
 else
 clear
 echo
 echo ....."In the folder \"/$nd\" No firmware \".ofp|.ops\" to extract images."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
ofp_extract
return
fi
return
}

 menu_ofp()
  {
              echo
              echo "         Unpacking firmware .ofp|.ops     "
              echo
 select img in "Unpack прошивку .ofp|.ops" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
                #1 ) #clear
                    #check_pack=0
                    #ofp_extract
                    #break ;;
                1 ) clear
                    check_pack=1
                    ofp_extract
                    #aa
                    break ;;
                2 ) clear
                    main_menu
                    return
                    break ;;
                3 ) clear
                     break ;;
                * ) clear
            echo
            echo "      Enter the numbers corresponding to Menu."
            echo
            menu_ofp
              break ;;
esac
 done
   return
 }
 menu_ofp
  break
   main_menu
    break ;;
         13 ) clear
             pac_extract()
{
              echo
              echo "         Unpacking firmware .pac     "
              
  pac_dir="/data/local/UnpackerSystem"

              echo
              echo "..Go to the folder where the File firmware \".pac\" is located, for example: cd /sdcard"
read b && $b
if [ $(echo $?) -eq 0 ]; then
clear
nd=$(echo $b | busybox awk '{ print $2 }' | busybox sed 's!^/!!')
echo
echo ".....Search files..."

 v=$(for a in $(busybox find . -maxdepth 1 -name '*.pac' -type f | busybox sed 's!./!!'); do
     echo "$a"
     done | busybox sort -f)

set -- $v

if [ ! -z "$v" ]; then
clear
echo
echo ".....Select file:"
echo
select menu in $v "Exit to the main Menu" "Completion of work"; do
case $REPLY in
                 [1-9]*) i="$#"
                        j="$#"
                      let i=i+1
                      let j=j+2
                      file=$(echo "$@" | busybox cut -d' ' -f"$REPLY")
         if [ ! -z "$file" -a "$REPLY" -lt "$i" ]; then
 clear
  name_pac="$(echo "$file" | busybox sed 's!.pac$!!')"
file=/"$nd"/"$file"
  
  if [ -d "$pac_dir"/"$name_pac" -a "$pac_dir"/"$name_pac" != "$pac_dir"/ ]; then
          echo
          echo ".....Deleting the old folder: "$pac_dir"/"$name_pac""
          busybox rm -rf "$pac_dir"/"$name_pac"
          fi
        echo
        echo "....Extracting images..."
        echo
         python31 /data/local/binary/pacextractor-test/python/pacExtractor.py -c "$file" "$pac_dir"/"$name_pac"
         if [ $(echo $?) -eq 0 ]; then
         echo
         echo ".....images extracted successfully!"
         echo ".....Saved в "$pac_dir"/"$name_pac""
         echo
         #main_menu
         #return
         else
         echo
         echo "......Error...Error while extracting imageов!"
         echo
         #main_menu
         #return
         fi
         #return
         main_menu
         return
         break 
         elif [ "$REPLY" == "$i" ]; then
         clear
        main_menu
        return
        break
        elif [ "$REPLY" -eq "$j" ]; then
         clear
         return
         break
        else
        clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         pac_extract
         return
         break
         fi
         break;;
   *) clear
        echo
            echo "      Enter the numbers corresponding to Menu."
         pac_extract
         return
         break ;;
  esac
 done
 else
 clear
 echo
 echo ....."In the folder \"/$nd\" No firmware \".pac\" to extract images."
 echo
 main_menu
return
fi
echo
else
echo
echo .....error: Error moving to directory!
echo
echo Please enter the directory correctly!
echo
pac_extract
return
fi
return
}

 menu_pac()
  {
              echo
              echo "         Unpacking firmware .pac     "
              echo
 select img in "Unpack прошивку .pac" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
                1 ) clear
                    pac_extract
                    break ;;
                2 ) clear
                    main_menu
                    return
                    break ;;
                3 ) clear
                     break ;;
                * ) clear
            echo
            echo "      Enter the numbers corresponding to Menu."
            echo
            menu_pac
              break ;;
esac
 done
   return
 }
 menu_pac
  break
   main_menu
    break ;;
         14 ) clear
             main_menu
             break ;;
         15 ) clear
             break ;;
         *) echo "Enter the number corresponding to the items Menu: Other tools" ;;
    esac
done
return
}
my2
 break ;;
         12) clear
         del_papka()
{
         rm -rf $del; mkdir $del; chmod 755 $del;

echo 
echo " .....Cleaning of folder completed: $del"
echo
return
}
            my9(){
            echo
            echo "      Menu: Cleaning working folders"
            echo
            echo -en "\E[31;47;1m"
            echo " Before cleaning, move the necessary Files to another folder! "
            echo -en "\E[37;0m"
            echo -en "\E[37;1m"
            echo
select img in "Clear folder: /data/local/UnpackerSystem" "Clear folder: /data/local/UnpackerQfil" "Clear folder: /data/local/UnpackerContexts" "Clear folder: /data/local/UnpackerPayload" "Clear folder: /data/local/UnpackerSuper" "Clear folder: /data/local/UnpackerUpdateApp" "Clear folder: /data/local/UnpackerPreloader" "Clear all folders at once" "Exit to the main Menu" "Completion of work"; do
case $REPLY in 
         1 ) clear
             del=/data/local/UnpackerSystem
             del_papka
             main_menu
             break ;;
         2 ) clear
             del=/data/local/UnpackerQfil
             del_papka
             main_menu
             break ;;
         3 ) clear
             del=/data/local/UnpackerContexts
             del_papka
             main_menu
             break ;;
         4 ) clear
             del=/data/local/UnpackerPayload
             del_papka
             main_menu
             break ;;
         5 ) clear
             del=/data/local/UnpackerSuper
             del_papka
             main_menu
             break ;;
         6 ) clear
             del=/data/local/UnpackerUpdateApp
             del_papka
             main_menu
             break ;;
         7 ) clear
             del=/data/local/UnpackerPreloader
             del_papka
             main_menu
             break ;;
         8 ) clear
            del_dir=/data/local/Unpacker
 for del_all in "$del_dir"Contexts "$del_dir"System "$del_dir"Qfil "$del_dir"Payload "$del_dir"Super "$del_dir"UpdateApp "$del_dir"Preloader; do
 rm -rf $del_all; mkdir $del_all; chmod 755 $del_all
 done
 echo 
 echo " .....Cleaning of all working folders completed."
 echo
             main_menu
             break ;;
         9 ) clear
             main_menu
             break ;;
         10 ) clear
             break ;;
         *) echo "Enter the number corresponding to the items Menu: Cleaning working folders" ;;
    esac
done
return
}
my9
break ;;
         13) clear

reb()
{
echo
 echo -ne "        Reboot in 5 sec      \r"
sleep 1
echo -ne "         ..... 5 .....                \r"
sleep 1
echo -ne "          .... 4 ....                 \r"
sleep 1
echo -ne "           ... 3 ...                  \r"
sleep 1
echo -ne "            .. 2 ..                   \r"
sleep 1
echo -ne "             . 1 .                    \r"
sleep 1
echo -ne "                                      \r"
}

             del_unpack()
{
echo
echo -en "\E[31;47;1m"
echo "     Remove \"Unpacker Kitchen for Android\" from your phone?     "
echo -en "\E[37;0m"
echo -en "\E[37;1m"
echo
select img in "Yes" "No, exit to main Menu"; do
case $REPLY in 
         1 ) clear
              if busybox test -d /data/local/AIK-mobile; then        
  
     echo
     echo ".....Removal AIK-mobile..."
 /data/local/AIK-mobile/cleanup.sh
 /data/local/AIK-mobile/bin/aik --uninstall 2> /dev/null
 #busybox mount -o rw,remount / 2> /dev/null
 #busybox mount -o rw,remount /system 2> /dev/null
  #busybox find $(echo $PATH | busybox sed 's!:! !g') -name 'aik' -type f -o -iname 'aik-mobile' -type d | busybox xargs busybox rm -rf 2> /dev/null
 busybox rm -rf /data/local/AIK-mobile /data/adb/modules/aik-mobile 2> /dev/null
#if [ $(echo $?) -eq 0 ]; then
echo
echo ".....AIK-mobile удалён!"
echo
#fi
fi
 delit_uka="/data/adb/modules/UKA/uninstall.sh"
 if busybox test -s "$delit_uka"; then
 busybox chmod 755 "$delit_uka" && "$delit_uka"
 #if [ $(echo $?) -eq 0 ]; then

 reb
 reboot
 
 #else
 elif busybox test -f /data/local/binary/UninstallerUnpack.zip -a ! -f "$delit_uka"; then
 busybox mkdir /cache/recovery 2> /dev/null
 busybox chmod 755 /cache/recovery 2> /dev/null
 busybox cp -f /data/local/binary/UninstallerUnpack.zip /cache/recovery/UninstallerUnpack.zip
 echo "install /cache/recovery/UninstallerUnpack.zip" > /cache/recovery/openrecoveryscript
 busybox chmod 755 /cache/recovery/openrecoveryscript 2> /dev/null

 reb
 reboot recovery
fi
#fi
#fi
               main_menu
               break ;;
         2 ) clear
               main_menu
               break ;;
         * ) clear
            echo
            echo "      Enter the numbers corresponding to this Menu."
              del_unpack
              break ;;
    esac
done
return
}
del_unpack
break ;;

         14) clear
             break ;;
         *) echo "Enter the number corresponding to the Menu items." ;;
    esac
done
return
}
main_menu
